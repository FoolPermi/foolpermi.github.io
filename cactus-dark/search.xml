<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Swift Basics</title>
      <link href="/cactus-dark/2019/11/04/Swift-Basics/"/>
      <url>/cactus-dark/2019/11/04/Swift-Basics/</url>
      <content type="html"><![CDATA[<h2 id="基础运算"><a href="#基础运算" class="headerlink" title="基础运算"></a>基础运算</h2><p>和其它编程语言一样，swift支持加 (+)、减 (-)、乘 (*)、除 (/)、取模 (%)、移位等多种基础运算。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> + <span class="number">6</span> <span class="comment">// ok</span></span><br><span class="line"><span class="number">2</span>+<span class="number">6</span> <span class="comment">// ok</span></span><br><span class="line"><span class="number">2</span> +<span class="number">6</span> <span class="comment">// error</span></span><br><span class="line"><span class="number">2</span>+ <span class="number">6</span> <span class="comment">// error</span></span><br><span class="line"><span class="number">2</span> - <span class="number">6</span></span><br><span class="line"><span class="number">2</span> * <span class="number">6</span></span><br><span class="line"><span class="number">6</span> / <span class="number">2</span></span><br><span class="line"><span class="number">6.0</span> / <span class="number">2.0</span></span><br><span class="line"><span class="number">28</span> % <span class="number">10</span></span><br><span class="line">(<span class="number">28.0</span>).truncatingRemainder(dividingBy: <span class="number">10.0</span>) <span class="comment">// 浮点数取模</span></span><br><span class="line"><span class="number">1</span> &lt;&lt; <span class="number">3</span> <span class="comment">// 8</span></span><br><span class="line"><span class="number">32</span> &gt;&gt; <span class="number">2</span> <span class="comment">// 8</span></span><br><span class="line">sin(<span class="number">45</span> * <span class="type">Double</span>.pi / <span class="number">180</span>)</span><br><span class="line">cos(<span class="number">135</span> * <span class="type">Double</span>.pi / <span class="number">180</span>)</span><br><span class="line">(<span class="number">2.0</span>).squareRoot()</span><br><span class="line"><span class="built_in">max</span>(<span class="number">5</span>, <span class="number">10</span>) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">min</span>(-<span class="number">5</span>, -<span class="number">10</span>) <span class="comment">// -10</span></span><br></pre></td></tr></table></figure><h2 id="let-VS-var"><a href="#let-VS-var" class="headerlink" title="let VS var"></a>let VS var</h2><p><strong>let</strong> 用来声明常量，<strong>var</strong> 用来声明变量。声明常量或变量的时候可以不指定数据类型，编译器会进行推断。但是一旦确定类型以后，便只能赋予相同类型的变量值。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> number: <span class="type">Int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> pi: <span class="type">Double</span> = <span class="number">3.14</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"Peter"</span> <span class="comment">// name is a string</span></span><br><span class="line">name = <span class="number">15</span> <span class="comment">// error</span></span><br><span class="line">name = <span class="string">"Linda"</span> <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="基本类型和操作符"><a href="#基本类型和操作符" class="headerlink" title="基本类型和操作符"></a>基本类型和操作符</h2><p>swift 中基本数据类型有 Int8, UInt8, Int16, UInt16, Int32, UInt32, Int64, UInt64, Float, Double. 大部分情况下可以直接使用 <strong>Int</strong> 和 <strong>Double</strong>.</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="type">Int16</span> = <span class="number">12</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="type">UInt8</span> = <span class="number">255</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span>: <span class="type">Int32</span> = -<span class="number">10000</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="type">Int</span>(a) + <span class="type">Int</span>(b) + <span class="type">Int</span>(<span class="built_in">c</span>) <span class="comment">// result is an Int</span></span><br></pre></td></tr></table></figure><p>swift 中表示单个字符和字符串时都是使用引号，当未明确指定类型时默认是字符串类型，所以如果期望表示单个字符，请一定指定类型。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> charA: <span class="type">Character</span> = <span class="string">"a"</span></span><br><span class="line"><span class="keyword">let</span> strA: <span class="type">String</span> = <span class="string">"a"</span></span><br><span class="line"><span class="keyword">let</span> strB = <span class="string">"b"</span> <span class="comment">// so if you want to make a Char, you must explicit its type</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"Jay"</span></span><br><span class="line"><span class="keyword">var</span> greeting = <span class="string">"My name is <span class="subst">\(name)</span>"</span> <span class="comment">// "My name is Jay"</span></span><br><span class="line"><span class="comment">// 多行字符串</span></span><br><span class="line"><span class="keyword">let</span> bigStr = <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">                This is </span></span><br><span class="line"><span class="string">                a Multiple lines</span></span><br><span class="line"><span class="string">                string.</span></span><br><span class="line"><span class="string">             "</span><span class="string">""</span></span><br></pre></td></tr></table></figure><p>Tuple 类型用来表示具有多个字段的数据元组。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> coordinates: (<span class="type">Int</span>, <span class="type">Int</span>) = (<span class="number">2</span>, <span class="number">3</span>) <span class="comment">// coordinates 的类型为 (Int, Int)</span></span><br><span class="line"><span class="keyword">let</span> location = (<span class="number">2.1</span>, <span class="number">3.5</span>, <span class="number">1</span>) <span class="comment">// location 类型推断为 (Double, Double, Int)</span></span><br><span class="line"><span class="keyword">let</span> x1 = coordinates.<span class="number">0</span> <span class="comment">// 使用下标访问 Tuple 中的元素</span></span><br><span class="line"><span class="keyword">let</span> y1 = coordinates.<span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> location3D = (x: <span class="number">2</span>, y: <span class="number">3</span>, z: <span class="number">4</span>) </span><br><span class="line"><span class="keyword">let</span> x2 = location3D.x <span class="comment">// 使用元素名访问 Tuple 中元素</span></span><br><span class="line"><span class="keyword">let</span> y2 = location3D.y</span><br><span class="line"><span class="keyword">let</span> z2 = location3D.z</span><br><span class="line"><span class="keyword">let</span> (x3, y3, z3) = location3D</span><br></pre></td></tr></table></figure><h2 id="Type-alias"><a href="#Type-alias" class="headerlink" title="Type alias"></a>Type alias</h2><p><strong>typealias</strong> 是 swift 中用来给类型指定别名的关键字，相当于 C 语言中的 typedef.</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">Animal</span> = <span class="type">String</span></span><br><span class="line"><span class="keyword">let</span> myPet: <span class="type">Animal</span> = <span class="string">"Dog"</span></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">Coordinates</span> = (<span class="type">Int</span>, <span class="type">Int</span>)</span><br><span class="line"><span class="keyword">let</span> xy: <span class="type">Coordinates</span> = (<span class="number">2</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><h2 id="Basic-Control-Flow"><a href="#Basic-Control-Flow" class="headerlink" title="Basic Control Flow"></a>Basic Control Flow</h2><h3 id="Bool-类型"><a href="#Bool-类型" class="headerlink" title="Bool 类型"></a>Bool 类型</h3><p>swift 中 Bool 类型的两种取值是 <strong>true</strong> 和 <strong>false</strong>.</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> yes: <span class="type">Bool</span> = <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> no: <span class="type">Bool</span> = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> and = (<span class="number">2</span> &gt; <span class="number">1</span>) &amp;&amp; (<span class="string">"Hello"</span> == <span class="string">"World"</span>)</span><br><span class="line"><span class="keyword">let</span> or = (<span class="number">2</span> &gt; <span class="number">1</span>) || (<span class="string">"Hello"</span> == <span class="string">"World"</span>)</span><br><span class="line"><span class="keyword">let</span> not = !(<span class="number">2</span> &gt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">var</span> switchState = <span class="literal">true</span></span><br><span class="line">switchState.toggle() <span class="comment">// switchState = false</span></span><br><span class="line">switchState.toggle() <span class="comment">// switchState = true</span></span><br></pre></td></tr></table></figure><h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><p>swift 中 if 语句后面的条件不需要使用<strong>括号()</strong>。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition1 &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> condition2 &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h3><p>和 if 语句类似，while 语句后面的条件也不需要使用括号。repeat-while 语句类似于其它语言中的 do-while, 循环体中的代码至少会被执行一次。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> condition &#123;</span><br><span class="line">    loop code</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">repeat</span> &#123;</span><br><span class="line">    loop code</span><br><span class="line">&#125; <span class="keyword">while</span> condition</span><br></pre></td></tr></table></figure><h3 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h3><p>swift 不支持 C Style 的 for 语句。而且在 for 语句的条件里面可以使用 where 关键字对循环的对象进行筛选。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> constant <span class="keyword">in</span> range &#123;</span><br><span class="line">    loop code</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// eg1:</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">count</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>...<span class="number">10</span> &#123; <span class="comment">// 此处 i 不需要使用 let 或 var </span></span><br><span class="line">    sum += i</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// eg2:</span></span><br><span class="line"><span class="keyword">let</span> step = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">10</span> &#123; <span class="comment">// 如果不需要访问 i 的值，可以使用 _ 代替</span></span><br><span class="line">    sum += step</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// eg3:</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>...<span class="number">10</span> <span class="keyword">where</span> i % <span class="number">2</span> == <span class="number">0</span> &#123; <span class="comment">// 可以使用 where 来指定附加条件, 只有 where 条件为 true 时，循环体才会执行</span></span><br><span class="line">    sum += i</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// eg4:</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">8</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> row % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">continue</span> <span class="comment">// 使用 continue 跳出本次循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> column <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">8</span> &#123;</span><br><span class="line">        sum += row * column</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// eg5:</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">rowLoop: <span class="keyword">for</span> row <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">8</span> &#123;</span><br><span class="line">    columnLoop: <span class="keyword">for</span> column <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">8</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> row == column &#123;</span><br><span class="line">            <span class="keyword">continue</span> rowLoop <span class="comment">// 通过添加 label，跳出指定 level 循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        sum += row * column</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h3><p>swift 中的 switch 语句非常灵活，可以匹配多种 case，而且 break不是必需的，除非 case 下面没有任何需要执行的 code 时，需要使用 break。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// eg1:</span></span><br><span class="line"><span class="keyword">let</span> animal = <span class="string">"Dog"</span></span><br><span class="line"><span class="keyword">switch</span> animal &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Dog"</span>, <span class="string">"Cat"</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"It is a house animal"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"It is not a house animal"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// eg2:</span></span><br><span class="line"><span class="keyword">let</span> hourOfDay = <span class="number">12</span></span><br><span class="line"><span class="keyword">var</span> timeOfDay = <span class="string">""</span></span><br><span class="line"><span class="keyword">switch</span> hourOfDay &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>:</span><br><span class="line">        timeOfDay = <span class="string">"Early morning"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>:</span><br><span class="line">        timeOfDay = <span class="string">"Morning"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>:</span><br><span class="line">        timeOfDay = <span class="string">"Afternoon"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>:</span><br><span class="line">        timeOfDay = <span class="string">"Evening"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>:</span><br><span class="line">        timeOfDay = <span class="string">"Later Evening"</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        timeOfDay = <span class="string">"Invalid time"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(timeOfDay)</span><br><span class="line"><span class="comment">// eg3:</span></span><br><span class="line"><span class="keyword">let</span> hourOfDay = <span class="number">12</span></span><br><span class="line"><span class="keyword">var</span> timeOfDay = <span class="string">""</span></span><br><span class="line"><span class="keyword">switch</span> hourOfDay &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>...<span class="number">5</span>:</span><br><span class="line">        timeOfDay = <span class="string">"Early morning"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>...<span class="number">11</span>:</span><br><span class="line">        timeOfDay = <span class="string">"Morning"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">12</span>...<span class="number">16</span>:</span><br><span class="line">        timeOfDay = <span class="string">"Afternoon"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">17</span>...<span class="number">19</span>:</span><br><span class="line">        timeOfDay = <span class="string">"Evening"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">20</span>...<span class="number">23</span>:</span><br><span class="line">        timeOfDay = <span class="string">"Later Evening"</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        timeOfDay = <span class="string">"Invalid time"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(timeOfDay)</span><br><span class="line"><span class="comment">// eg4:</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">10</span></span><br><span class="line"><span class="keyword">switch</span> num &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> x <span class="keyword">where</span> x % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Even"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Odd"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// eg5:</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">10</span></span><br><span class="line"><span class="keyword">switch</span> num &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">_</span> <span class="keyword">where</span> num % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Even"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Odd"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// eg6:</span></span><br><span class="line"><span class="keyword">let</span> coordinates = (x: <span class="number">3</span>, y: <span class="number">2</span>, z: <span class="number">5</span>)</span><br><span class="line"><span class="keyword">switch</span> coordinates &#123;</span><br><span class="line">    <span class="keyword">case</span> (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Origin"</span>)</span><br><span class="line">    <span class="keyword">case</span> (<span class="number">_</span>, <span class="number">0</span>, <span class="number">0</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"X-axis"</span>)</span><br><span class="line">    <span class="keyword">case</span> (<span class="number">0</span>, <span class="number">_</span>, <span class="number">0</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Y-axis"</span>)</span><br><span class="line">    <span class="keyword">case</span> (<span class="number">0</span>, <span class="number">0</span>, <span class="number">_</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Z-axis"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Somewhere"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// eg7:</span></span><br><span class="line"><span class="keyword">let</span> coordinates = (x: <span class="number">3</span>, y: <span class="number">2</span>, z: <span class="number">5</span>)</span><br><span class="line"><span class="keyword">switch</span> coordinates &#123;</span><br><span class="line">    <span class="keyword">case</span> (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Origin"</span>)</span><br><span class="line">    <span class="keyword">case</span> (<span class="keyword">let</span> x, <span class="number">0</span>, <span class="number">0</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"X-axis at x = <span class="subst">\(x)</span>"</span>)</span><br><span class="line">    <span class="keyword">case</span> (<span class="number">0</span>, <span class="keyword">let</span> y, <span class="number">0</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Y-axis at y = <span class="subst">\(y)</span>"</span>)</span><br><span class="line">    <span class="keyword">case</span> (<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">let</span> z):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Z-axis at z = <span class="subst">\(z)</span>"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span>(x, y, z):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Somewhere at (<span class="subst">\(x)</span>, <span class="subst">\(y)</span>, <span class="subst">\(z)</span>)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// eg8</span></span><br><span class="line"><span class="keyword">let</span> coordinates = (x: <span class="number">3</span>, y: <span class="number">2</span>, z: <span class="number">5</span>)</span><br><span class="line"><span class="keyword">switch</span> coordinates &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> (x, y, <span class="number">_</span>) <span class="keyword">where</span> y == x:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Y-X Line"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> (x, y, <span class="number">_</span>) <span class="keyword">where</span> y == x * x:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Y-X^2 Line"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考: Swift Apprentice</p>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> swift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Generics in Swift</title>
      <link href="/cactus-dark/2016/11/28/Generics-in-Swift/"/>
      <url>/cactus-dark/2016/11/28/Generics-in-Swift/</url>
      <content type="html"><![CDATA[<p><strong>泛型 (Generics)</strong> 是 Swift 中最强大的特性之一，许多 Swift 的标准库也都是基于泛型的代码构建的。使用泛型可以让你根据自定义的需求，编写出适用于任意类型、灵活可重用的函数和类型。例如 Swift 中的 Array 和 Dictionary 都是泛型集合，你可以创建一个 Int 数组，也可以创建一个 String 数组，还可以创建其它类型的数组。当然，也可以创建任意指定类型的字典，本文的主要内容包括：</p><ul><li>泛型解决的问题 (The problems generic solve)</li><li>泛型函数 (Generic functions)</li><li>泛型类型 (Generic types)</li><li>扩展泛型类型 (Extending a generic type)</li><li>类型约束 (Type constrains)</li><li>关联类型 (Associated type)</li><li>Where 语句 (Generic where clauses)</li></ul><a id="more"></a><h2 id="The-problem-generics-solve"><a href="#The-problem-generics-solve" class="headerlink" title="The problem generics solve"></a>The problem generics solve</h2><p>下面是一个标准的非泛型函数 swapTwoInts，用来交换两个 Int 值：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwoInts</span><span class="params">(<span class="number">_</span> a: <span class="keyword">inout</span> Int, <span class="number">_</span> b: <span class="keyword">inout</span> Int)</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> temp = a</span><br><span class="line">  a = b</span><br><span class="line">  b = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码使用输入输出参数 (inout) 来交换 a 和 b 的值：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> someInt = <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> anotherInt = <span class="number">107</span></span><br><span class="line">swapTwoInts(&amp;someInt, &amp;anotherInt)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"someInt = <span class="subst">\(someInt)</span>, anotherInt = <span class="subst">\(anotherInt)</span>"</span>) <span class="comment">// someInt = 107, anotherInt = 3</span></span><br></pre></td></tr></table></figure><p>当然，swapTwoInts 函数挺有用，但是缺点也同样明显，就是它只能交换 Int 的值，如果想要交换两个 Double 或者 String 的值，你还必须重写一个类似的函数：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwoDoubles</span><span class="params">(<span class="number">_</span> a: <span class="keyword">inout</span> Double, <span class="number">_</span> b: <span class="keyword">inout</span> Double)</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> temp = a</span><br><span class="line">  a = b</span><br><span class="line">  b = temp</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwoStrings</span><span class="params">(<span class="number">_</span> a: <span class="keyword">inout</span> String, <span class="number">_</span> b: <span class="keyword">inout</span> String)</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> temp = a</span><br><span class="line">  a = b</span><br><span class="line">  b = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，上面的函数除了参数类型以外，实现过程完全相同。在实际应用中，通常需要一个更实用更灵活的函数来交换两个任意类型的值，这就需要使用泛型代码。</p><h2 id="Generic-functions"><a href="#Generic-functions" class="headerlink" title="Generic functions"></a>Generic functions</h2><p>泛型函数可适用于任意类型，下面的 swapTwoValues 函数就是上面3个函数的泛型版本：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwoValues</span>&lt;T&gt;<span class="params">(<span class="number">_</span> a: <span class="keyword">inout</span> T, <span class="number">_</span> b: <span class="keyword">inout</span> T)</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> temp = a</span><br><span class="line">  a = b </span><br><span class="line">  b = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>swapTwoValues的函数主体和之前的函数完全相同，唯一的不同是在函数声明的时候：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwoInts</span><span class="params">(<span class="number">_</span> a: <span class="keyword">inout</span> Int, <span class="number">_</span> b: <span class="keyword">inout</span> Int)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwoValues</span>&lt;T&gt;<span class="params">(<span class="number">_</span> a: <span class="keyword">inout</span> T, <span class="number">_</span> b: <span class="keyword">inout</span> T)</span></span></span><br></pre></td></tr></table></figure><p>这个泛型函数的声明使用了占位类型名 (这里是 T) 来代替实际类型名 (例如 Int、Double、String)。占位类型符 T 并没有指出具体是什么类型，但它约束了 a 和 b 必须是同一类型。在函数调用的时候会根据实际传入的类型决定 T 的类型。现在函数 swapTwoValues 和前面的函数一样调用，只是这个函数可以接受两个任意类型的参数，只是这两个参数类型必须相同。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> someInt = <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> anotherInt = <span class="number">107</span></span><br><span class="line">swapTwoValues(&amp;someInt, &amp;anotherInt)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"someInt = <span class="subst">\(someInt)</span>, anotherInt = <span class="subst">\(anotherInt)</span>"</span>) <span class="comment">// someInt = 107, anotherInt = 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> someStr = <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">var</span> anotherStr = <span class="string">"world"</span></span><br><span class="line">swapTwoValues(&amp;someStr, &amp;anotherStr) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"someStr = <span class="subst">\(someStr)</span>, anotherStr = <span class="subst">\(anotherStr)</span>"</span>) <span class="comment">// someStr = world, anotherStr = hello</span></span><br></pre></td></tr></table></figure><h2 id="Generic-types"><a href="#Generic-types" class="headerlink" title="Generic types"></a>Generic types</h2><p>除了泛型函数，Swift 还允许定义泛型类型，这些自定义的结构体、类、枚举可以适用于任何类型，类似于 Array 和 Dictionary。下面的例子是编写一个名为 Stack 的泛型集合类型，首先展示一个非泛型的版本：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IntStack</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> items = [<span class="type">Int</span>]()</span><br><span class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">push</span><span class="params">(<span class="number">_</span> item: Int)</span></span> &#123;</span><br><span class="line">    items.append(item)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> items.removeLast()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的结构体可以进行入栈和出栈的操作，但是只适用于 Int 类型，对应的泛型版本如下：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> items = [<span class="type">Element</span>]()</span><br><span class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">push</span><span class="params">(<span class="number">_</span> item: Element)</span></span> &#123;</span><br><span class="line">    items.append(item)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span> -&gt; <span class="type">Element</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> items.removeLast()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Stack 基本上和 IntStack 相同，只是用占位类型 Element 代替了实际类型 Int，这个类型参数包裹在紧随结构体名的一对尖括号里。Element 为待提供的类型定义了一个占位符，这种占位符可以在结构体中需要类型信息的时候使用。使用泛型版本的 Stack 就可以创建 Swift 中任意有效类型的栈，就像 Array 和 Dictionary 那样。在 Stack 实例化的时候，可以在尖括号中写出 Stack 中的数据类型：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> stackOfStrings = <span class="type">Stack</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">stackOfStrings.push(<span class="string">"uno"</span>)</span><br><span class="line">stackOfStrings.push(<span class="string">"dos"</span>)</span><br><span class="line">stackOfStrings.push(<span class="string">"tres"</span>)</span><br><span class="line"><span class="keyword">let</span> fromTheTop = stackOfStrings.pop()</span><br></pre></td></tr></table></figure><h2 id="Extending-a-generic-type"><a href="#Extending-a-generic-type" class="headerlink" title="Extending a generic type"></a>Extending a generic type</h2><p>当扩展一个泛型类型的时候并不需要在扩展的定义中提供类型参数列表，原始类型定义中声明的类型参数列表在扩展中可以直接使用，并且这些来自原始类型的参数名称会被用作原始定义中类型参数的引用。下面扩展泛型类型 Stack，为其添加一个名为 topItem 的只读计算属性用来返回栈顶的元素：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Stack</span> </span>&#123; <span class="comment">// 并没有类型列表</span></span><br><span class="line">  <span class="keyword">var</span> topItem: <span class="type">Element</span>? &#123;</span><br><span class="line">    <span class="keyword">return</span> items.isEmpty ? <span class="literal">nil</span> : items[items.<span class="built_in">count</span> - <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个扩展并没有定义一个类型参数列表，原有 Stack 中的类型参数列表可以直接使用。</p><h2 id="Type-constraints"><a href="#Type-constraints" class="headerlink" title="Type constraints"></a>Type constraints</h2><p>可以给一个类型参数添加约束以使得类型符合特定的条件。在一个类型参数名后面放置一个类名或协议名，并用冒号进行分隔，来定义类型约束，它们将成为类型参数列表的一部分。对泛型函数添加类型约束的基本语法如下：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunction</span>&lt;T: SomeClass, U: SomeProtocol&gt;<span class="params">(someT: T, someU: U)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 泛型函数的实现部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个函数有两个类型参数。第一个类型参数 是T，有一个要求 T 必须是 SomeClass 子类的类型约束；第二个类型参数是U，有一个要求 U 必须符合 SomeProtocol 协议的类型约束。</p><h2 id="Associated-type"><a href="#Associated-type" class="headerlink" title="Associated type"></a>Associated type</h2><p>当定义一个协议时，有的时候声明一个或多个关联类型作为协议定义的一部分是非常有用的，一个关联类型作为协议的一部分，给定了类型的一个占位名作用于关联类型上，实际类型在协议被实现前是不需要指定的。使用 typealias 指定关联类型。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">  associatedtype <span class="type">ItemType</span></span><br><span class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(item: ItemType)</span></span></span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  <span class="keyword">subscript</span>(i: <span class="type">Int</span>) -&gt; <span class="type">ItemType</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Container 定义了一个容器必须满足的3个要求：</p><ul><li>必须可以通过 append 方法添加一个新的 item 到容器中</li><li>必须可以通过使用 count 属性获取容器中元素的个数</li><li>必须可以通过索引获取容器中的各个元素</li></ul><p>这里让早先的 IntStack 类型遵守 Container 协议：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IntStack</span>: <span class="title">Container</span> </span>&#123;</span><br><span class="line">  <span class="comment">// IntStack的原始实现</span></span><br><span class="line">  <span class="keyword">var</span> items = [<span class="type">Int</span>]()</span><br><span class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">push</span><span class="params">(<span class="number">_</span> item: Int)</span></span> &#123;</span><br><span class="line">    items.append(item)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> items.removeLast()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遵守Container协议的实现</span></span><br><span class="line">  <span class="keyword">typealias</span> <span class="type">ItemType</span> = <span class="type">Int</span></span><br><span class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(item: Int)</span></span>&#123;</span><br><span class="line">    <span class="keyword">self</span>.push(item)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> items.<span class="built_in">count</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">subscript</span>(i: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> items[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以生成遵循 Container 协议的泛型版本的 Stack 类型：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&lt;<span class="title">T</span>&gt;: <span class="title">Container</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Stack的原始实现</span></span><br><span class="line">  <span class="keyword">var</span> items = [<span class="type">T</span>]()</span><br><span class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">push</span><span class="params">(<span class="number">_</span> item: T)</span></span> &#123;</span><br><span class="line">    items.append(item)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> items.removeLast()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遵守Container协议的实现</span></span><br><span class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(item: T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.push(item)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> items.<span class="built_in">count</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">subscript</span>(i: <span class="type">Int</span>) -&gt; <span class="type">T</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> items[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Generic-where-clauses"><a href="#Generic-where-clauses" class="headerlink" title="Generic where clauses"></a>Generic where clauses</h2><p>对关联类型定义约束是非常有用的，你可以在参数列表中通过 where 语句定义参数的约束。一个 where 语句可以使一个关联类型遵守一个特定的协议。可以写一个 where 语句，紧跟在类型参数列表的后面，where 语句后跟一个或多个针对关联类型的约束。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allItemsMatch</span>&lt;C1: Container, C2: Container&gt;<span class="params">(someContainer: C1, anotherContainer: C2)</span></span> -&gt; <span class="type">Bool</span> <span class="keyword">where</span> <span class="type">C1</span>.<span class="type">ItemType</span> == <span class="type">C2</span>.<span class="type">ItemType</span>, <span class="type">C1</span>.<span class="type">ItemType</span>: <span class="type">Equatable</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> someContainer.<span class="built_in">count</span> != anotherContainer.<span class="built_in">count</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;someContainer.<span class="built_in">count</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> someContainer[i] != anotherContainer[i] &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<em>The Swift Programming Language</em></p>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> swift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Enumerations in Swift</title>
      <link href="/cactus-dark/2016/11/27/Enumerations-in-Swift/"/>
      <url>/cactus-dark/2016/11/27/Enumerations-in-Swift/</url>
      <content type="html"><![CDATA[<p>枚举为一组相关的值定义了一个共同的类型，以便在代码中以类型安全的方式使用这些值。在 C 语言中，枚举会为枚举成员分配一个对应的整形值。Swift 中的枚举更加灵活，可以不必为每一个成员提供对应的值。在 Swift 中这个值被称为<strong>原始值 (Raw Value)</strong>，原始值的类型可以是字符串，字符，整形值或浮点数。与枚举有关的内容主要包括：</p><ul><li>基本语法 (Basics)</li><li>原始值 (Raw values)</li><li>关联值 (Associated values)</li><li>没有成员的枚举 (Case-less enumerations)</li><li>递归枚举 (Recursive enumerations)</li></ul><p>主要参考了 <em>Swift Apprentice</em> 和 <em>The Swift Programming Language</em>。</p><a id="more"></a><h2 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h2><p>定义一个枚举类型和定义类和结构体类似，只是使用 <strong>enum</strong> 关键字，然后在枚举成员前标上 <strong>case</strong> 关键字。假如要写一个函数，函数接收一个用来表示月份的字符串，输出对应的学期，那么可以使用一个字符串数组实现：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> months = [<span class="string">"January"</span>, <span class="string">"February"</span>, <span class="string">"March"</span>, <span class="string">"April"</span>, <span class="string">"May"</span>, <span class="string">"June"</span>, <span class="string">"July"</span>, <span class="string">"August"</span>,<span class="string">"September"</span>, <span class="string">"October"</span>, <span class="string">"November"</span>, <span class="string">"December"</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">semester</span><span class="params">(<span class="keyword">for</span> month: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> month &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"January"</span>, <span class="string">"February"</span>, <span class="string">"March"</span>, <span class="string">"April"</span>, <span class="string">"May"</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Spring"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"August"</span>, <span class="string">"September"</span>, <span class="string">"October"</span>, <span class="string">"November"</span>, <span class="string">"December"</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Autumn"</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Not in the school year"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">semester(<span class="keyword">for</span>: <span class="string">"April"</span>) <span class="comment">// Spring</span></span><br></pre></td></tr></table></figure><p>上面的代码可以实现需要的功能，但是输入一个字符串的时候容易出现错误，而这种错误会使结果不正确。所以就可以改用一个枚举类型来实现上面的函数，这样输入的时候会进行类型检查和自动补全，可以避免错误的产生。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Month</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> january, february, march, april, may, june, july, august, september, october, november, december</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重写semester函数，参数类型为Month而不再是String</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">semester</span><span class="params">(<span class="keyword">for</span> month: Month)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> month &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Month</span>.january, <span class="type">Month</span>.february, <span class="type">Month</span>.march, <span class="type">Month</span>.april, <span class="type">Month</span>.may:</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Spring"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Month</span>.august, <span class="type">Month</span>.september, <span class="type">Month</span>.october, <span class="type">Month</span>.november, <span class="type">Month</span>.december:</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Autumn"</span></span><br><span class="line">  <span class="keyword">default</span>: </span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Not in the school year"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 Swift 会根据参数类型进行推断，所以 semester 函数还可以写成下面的样子：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">semester</span><span class="params">(<span class="keyword">for</span> month: Month)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> month &#123;</span><br><span class="line">    <span class="keyword">case</span> .january, .february, .march, .april, .may:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Spring"</span></span><br><span class="line">    <span class="keyword">case</span> .august, .september, .october, .november, .december:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Autumn"</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Not in the school year"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Switch 语句要求是完备的，也就是所列的 case 中必须包括所有可能的情况，对于不需要处理的情况，可以放在 default 中。所以当 month 的类型是 String 时，你就必须要使用 default，因为你不可能列出所有可能的字符串。而使用 Month 类型以后，就可以在下面的代码中安全的移除 default。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">semester</span><span class="params">(<span class="keyword">for</span> month: Month)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> month &#123;</span><br><span class="line">    <span class="keyword">case</span> .january, .february, .march, .april, .may:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"String"</span></span><br><span class="line">    <span class="keyword">case</span> .june, .july:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Summer"</span></span><br><span class="line">    <span class="keyword">case</span> .august, .september, .october, .november, .december:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Autumn"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Swift 的枚举类型中还可以定义计算属性和方法，方法既可以是成员方法也可以是类型方法，但是不可以定义存储属性。比如上面的函数我们可以作为计算属性，写在 Month 内部。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Month</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> january, february, march, april, may, june, july, august, september, october, november, december</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> semester: <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> .january, .february, .march, .april, .may:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"String"</span></span><br><span class="line">      <span class="keyword">case</span> .june, .july:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Summer"</span></span><br><span class="line">      <span class="keyword">case</span> .august, .september, .october, .november, .december:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Autumn"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> may = <span class="type">Month</span>.may</span><br><span class="line">may.semester <span class="comment">// Spring</span></span><br></pre></td></tr></table></figure><h2 id="Raw-values"><a href="#Raw-values" class="headerlink" title="Raw values"></a>Raw values</h2><p>Swift 不会自动为枚举中的成员自动生成一个对应的整型值，但是仍然允许根据需要为各个成员指定一个值而且值的类型不仅仅局限于整形。假如要为 Month 中的成员指定一个对应的数字与之对应，可以使用下面的语句：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Month</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> january = <span class="number">1</span>, february = <span class="number">2</span>, march = <span class="number">3</span>, april = <span class="number">4</span>, may = <span class="number">5</span>, june = <span class="number">6</span>, july = <span class="number">7</span>, august = <span class="number">8</span>, september = <span class="number">9</span>, october = <span class="number">10</span>, november = <span class="number">11</span>, december = <span class="number">12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同 C 语言类似，并不需要为每一个成员都指定一个值，后面的值会根据前面的值递增。所以上面的代码与下面的等价：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Month</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> january = <span class="number">1</span>, february, march, april, may, june, july, august, september, october, november, december</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若要访问成员对应的值，可以使用 <strong>rawValue</strong> 属性，比如下面的函数可以用来计算本年度还剩下几个月：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">monthUntilWinterBreak</span><span class="params">(from month: Month)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">Month</span>.december.rawValue - month.rawValue</span><br><span class="line">&#125;</span><br><span class="line">monthUntilWinterBreak(from: .april) <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><p>枚举中的成员还可以使用 rawValue 进行初始化：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fifthMonth = <span class="type">Month</span>(rawValue: <span class="number">5</span>)! <span class="comment">// 使用 rawValue 初始化返回的是一个可选值</span></span><br><span class="line">monthUntilWinterBreak(from: fifthMonth) <span class="comment">// 7</span></span><br></pre></td></tr></table></figure><h3 id="String-raw-values"><a href="#String-raw-values" class="headerlink" title="String raw values"></a>String raw values</h3><p>枚举类型的 rawValue 还可以指定为 String，假如没有为成员指定特定的字符串，默认生成的字符串与成员的名字相同。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Icon</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> music</span><br><span class="line">  <span class="keyword">case</span> sports</span><br><span class="line">  <span class="keyword">case</span> weather</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Icon</span>.music.rawValue <span class="comment">// "music"</span></span><br></pre></td></tr></table></figure><h3 id="Unordered-raw-values"><a href="#Unordered-raw-values" class="headerlink" title="Unordered raw values"></a>Unordered raw values</h3><p>rawValue 不要求是有序的，所以完全可以根据需要定义 rawValue 的值：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Coin</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> penny = <span class="number">1</span></span><br><span class="line">  <span class="keyword">case</span> nickel = <span class="number">5</span></span><br><span class="line">  <span class="keyword">case</span> dime = <span class="number">10</span></span><br><span class="line">  <span class="keyword">case</span> quarter = <span class="number">25</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> coin = <span class="type">Coin</span>.quarter</span><br><span class="line">coin.rawValue <span class="comment">// 25</span></span><br></pre></td></tr></table></figure><h2 id="Associated-values"><a href="#Associated-values" class="headerlink" title="Associated values"></a>Associated values</h2><p>除了可以为枚举成员定义原始值，还可以定义关联值。这样就可以为成员存储额外的自定义信息，并且每次在代码中使用该枚举成员时，还可以修改这个关联值。关联值可以是任意类型，而且各个成员之间的关联值类型可以互不相同。假如一个库存跟踪系统需要支持两种不同类型的条形码来跟踪商品，有些商品上使用数字标记的一维条形码，有些商品使用标有 QR 码格式的二维码。每个一维条形码都由4个字段组成，分别表示数字系统、厂商代码、产品代码和检查位。所以枚举类型可以定义为如下格式：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Barcode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> upc(<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>) <span class="comment">// upc的关联值类型为包含4个Int的元组</span></span><br><span class="line">  <span class="keyword">case</span> qrCode(<span class="type">String</span>) <span class="comment">// qrCode的关联值类型为String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的定义没有提供任何关联值，它只是定义了枚举中各个成员的关联值的类型。然后可以使用任意一种条形码类型创建新的条码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> productBarcode = <span class="type">Barcode</span>.upc(<span class="number">8</span>, <span class="number">85909</span>, <span class="number">51226</span>, <span class="number">3</span>) <span class="comment">// 创建一个变量，设置其类型和关联值</span></span><br><span class="line">productBarcode = .qrCode(<span class="string">"ABCDEFG"</span>) <span class="comment">// 同一个商品还可以分配一个不同类型的二维码</span></span><br></pre></td></tr></table></figure><p>原始的 Barcode.upc 及其关联值被新的 Barcode.qrCode 及其关联值替代。Barcode 类型的变量或常量可以存储一个 .upc 或者 .qrCode 但是同一时间只能存储两个值中的一个。可以使用 switch 语句来检查不同的条码类型，这时关联值也可以使用 let 或 var 提取出来使用：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> productBarcode &#123;</span><br><span class="line">  <span class="keyword">case</span> .upc(<span class="keyword">let</span> numberSystem, <span class="keyword">let</span> manufacturer, <span class="keyword">let</span> product, <span class="keyword">let</span> check):</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"UPC: <span class="subst">\(numberSystem)</span>, <span class="subst">\(manufacturer)</span>, <span class="subst">\(product)</span>, <span class="subst">\(check)</span>"</span>)</span><br><span class="line">  <span class="keyword">case</span> .qrCode(<span class="keyword">let</span> productCode):</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"QR code: <span class="subst">\(productCode)</span>"</span>)</span><br><span class="line">&#125; <span class="comment">// 打印 "QR code: ABCDEFG"</span></span><br></pre></td></tr></table></figure><p>如果一个枚举成员的所有关联值都被提取为常量或者变量，那就可以只在成员名称前标注一个 let 或者 var。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> productBarcode &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="keyword">let</span> .upc(numberSystem, manufacturer, product, check):</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"UPC: <span class="subst">\(numberSystem)</span>, <span class="subst">\(manufacturer)</span>, <span class="subst">\(product)</span>, <span class="subst">\(check)</span>"</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="keyword">let</span> .qrCode(productCode):</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"QR code: <span class="subst">\(productCode)</span>"</span>)</span><br><span class="line">&#125; <span class="comment">// 打印 "QR code: ABCDEFG"</span></span><br></pre></td></tr></table></figure><h2 id="Case-less-enumerations"><a href="#Case-less-enumerations" class="headerlink" title="Case-less enumerations"></a>Case-less enumerations</h2><p>在将结构体的时候曾经说过可以通过将某一类的方法定义为类型方法放在结构体中，产生类似于命名空间的作用。比如计算阶乘的方法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Math</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">factorial</span><span class="params">(of number: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span>...number).<span class="built_in">reduce</span>(<span class="number">1</span>, *)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> factorial = <span class="type">Math</span>.factorial(of: <span class="number">6</span>) <span class="comment">// 720</span></span><br><span class="line"><span class="keyword">let</span> math = <span class="type">Math</span>()</span><br></pre></td></tr></table></figure><p>有一个问题可能已经注意到了就是结构体 Math 是可以实例化的，但是 Math 中仅有一个类型方法，所以实例化是没有意义的。在这种情况下，更好的实现是将 Math 由结构体类型改为枚举类型，这样在没有任何成员变量的情况下对枚举类型进行实例化会产生错误。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Math</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">factorial</span><span class="params">(of number: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span>...number).<span class="built_in">reduce</span>(<span class="number">1</span>, *)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> factorial = <span class="type">Math</span>.factorial(of: <span class="number">6</span>) <span class="comment">// 720</span></span><br><span class="line"><span class="keyword">let</span> math = <span class="type">Math</span>() <span class="comment">// error</span></span><br></pre></td></tr></table></figure><h2 id="Recursive-enumerations"><a href="#Recursive-enumerations" class="headerlink" title="Recursive enumerations"></a>Recursive enumerations</h2><p>递归枚举是一种枚举类型，它有一个或多个枚举成员使用该枚举类型的实例作为关联值，使用递归枚举时，编译器会插入一个间接层，可以在枚举成员前加上 <strong>indirect</strong> 来表示该成员可递归，例如下面的例子中，枚举类型存储了简单的算术表达式：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ArithmeticExpression</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> number(<span class="type">Int</span>)</span><br><span class="line">  <span class="keyword">indirect</span> <span class="keyword">case</span> addition(<span class="type">ArithmeticExpression</span>, <span class="type">ArithmeticExpression</span>)</span><br><span class="line">  <span class="keyword">indirect</span> <span class="keyword">case</span> multiplication(<span class="type">ArithmeticExpression</span>, <span class="type">ArithmeticExpression</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，也可以在枚举类型开头加上 indirect 关键字来表示它的所有成员都是可递归的。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">indirect</span> <span class="class"><span class="keyword">enum</span> <span class="title">ArithmeticExpression</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> number(<span class="type">Int</span>)</span><br><span class="line">  <span class="keyword">case</span> addition(<span class="type">ArithmeticExpression</span>, <span class="type">ArithmeticExpression</span>)</span><br><span class="line">  <span class="keyword">case</span> multiplication(<span class="type">ArithmeticExpression</span>, <span class="type">ArithmeticExpression</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面定义的枚举类型可以存储3种表达式：纯数字、两个表达式求和、两个表达式求积。枚举成员 addition 和 multiplication 的关联值也是算术表达式，这些关联值使得嵌套表达式成为可能。例如表达式 (5 + 4) * 2，乘号左边是个表达式，右边是纯数字。下面使用 ArithmeticExpression 这个递归枚举创建表达式。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> five = <span class="type">ArithmeticExpression</span>.number(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">let</span> four = <span class="type">ArithmeticExpression</span>.number(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">let</span> sum = <span class="type">ArithmeticExpression</span>.addition(five, four)</span><br><span class="line"><span class="keyword">let</span> product = <span class="type">ArithmeticExpression</span>.multiplication(sum, <span class="type">ArithmeticExpression</span>.number(<span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>要操作具有递归性质的数据结构，使用递归函数是一种直截了当的方式，例如下面一个对算术表达式求值的函数：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evaluate</span><span class="params">(<span class="number">_</span> expression: ArithmeticExpression)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> expression &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .number(value):</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .addition(<span class="keyword">left</span>, <span class="keyword">right</span>):</span><br><span class="line">    <span class="keyword">return</span> evaluate(<span class="keyword">left</span>) + evaluate(<span class="keyword">right</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .multiplication(<span class="keyword">left</span>, <span class="keyword">right</span>):</span><br><span class="line">    <span class="keyword">return</span> evaluate(<span class="keyword">left</span>) * evaluate(<span class="keyword">right</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span> (evaluate(product))</span><br></pre></td></tr></table></figure><p>该函数遇到纯数字就直接返回数字的值，如果遇到加法和乘法就会递归计算出表达式的值。</p>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> swift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Closures in Swift</title>
      <link href="/cactus-dark/2016/11/25/Closures-in-Swift/"/>
      <url>/cactus-dark/2016/11/25/Closures-in-Swift/</url>
      <content type="html"><![CDATA[<p>闭包是 Swift 中的重要语法，与 Objective-C 中的 block 类似，本文主要总结 Swift 中闭包的基本用法。主要参考了 <em>Swift Apprentice</em> 和 <em>The Swift Programming Language</em>，关于自动闭包的部分则参考了 <a href="http://www.jianshu.com/p/f9ba4c41d9c7" target="_blank" rel="noopener"><em>bestswifter</em></a> 的文章。主要内容包括：</p><ul><li>基本语法 (Basics)</li><li>简化规则 (Short syntax)</li><li>无返回值的闭包 (Closures with no return value)</li><li>闭包的值捕获 (Capturing from enclosing scope)</li><li>逃逸闭包 (Escaping closures)</li><li>自动闭包 (Autoclosures)</li></ul><a id="more"></a><h2 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h2><p><strong>闭包( closure )</strong>是一种没有名字的函数，封装了一段代码块，执行指定的操作。之所以称之为“闭包”是因为它有一个重要的特性，可以捕获作用域内的变量并在闭包内进行访问。因为闭包是一个没有名字的函数，那么要使用一个闭包可以通过将闭包赋给一个常量或者变量，然后使用常量或者变量的名字进行访问。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// multiplyClosure 是一个闭包，接收两个Int参数，返回一个Int值</span></span><br><span class="line"><span class="keyword">var</span> multiplyClosure: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span> </span><br><span class="line"><span class="comment">// 给multiplyClosure赋值，关键字in用于区分类型和实现</span></span><br><span class="line">multiplyClosure = &#123; (a: <span class="type">Int</span>, b: <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line"><span class="keyword">return</span> a * b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 像调用函数一样调用闭包</span></span><br><span class="line"><span class="keyword">let</span> result = multiplyClosure(<span class="number">4</span>, <span class="number">2</span>) <span class="comment">// result = 8</span></span><br></pre></td></tr></table></figure><h2 id="Short-syntax"><a href="#Short-syntax" class="headerlink" title="Short syntax"></a>Short syntax</h2><p>同函数相比，闭包在设计的时候就要求更加简单、轻量，所以也就有很多语法糖可以把闭包书写的更加简单。</p><ul><li>假如闭包中只包括一条 return 语句，那么可以省略 return关键字，所以上面的 multiplyClosure 可以改为：</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">multiplyClosure = &#123; (a: <span class="type">Int</span>, b: <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">a * b </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过 Swift 的类型推断，在闭包的实现部分可以省略闭包中参数和返回值的类型，所以 multiplyClosure 可以改为：</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> multiplyClosure: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span> </span><br><span class="line"><span class="comment">// 因为声明闭包的时候已经指定了参数和返回类型，所以实现部分可以省略</span></span><br><span class="line">multiplyClosure = &#123; (a, b) <span class="keyword">in</span> </span><br><span class="line">a * b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Swift 会将闭包中的参数指定为 <strong>$0</strong>,<strong>$1</strong>…分别对应闭包中的参数列表，所以实现的时候还可以省略闭包的参数列表。</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">multiplyClosure = &#123; </span><br><span class="line">$<span class="number">0</span> * $<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，闭包的<strong>参数列表</strong>，<strong>return 关键字</strong>，<strong>in 关键字</strong>全部都可以被省略了。</p><p>考虑下面的函数 operateOnNumbers，函数接收两个 Int 参数和一个闭包，根据闭包指定的操作对两个 Int 参数进行计算。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">operateOnNumbers</span><span class="params">(<span class="number">_</span> a: Int, <span class="number">_</span> b: Int, operation: <span class="params">(Int, Int)</span></span></span> -&gt; <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> result = operation(a, b)</span><br><span class="line">  <span class="built_in">print</span>(result)</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用上面的函数的时候，可以先定义一个闭包，然后将闭包传给 operateOnNumbers 函数。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义闭包</span></span><br><span class="line"><span class="keyword">let</span> addClosure = &#123; (a: <span class="type">Int</span>, b: <span class="type">Int</span>) <span class="keyword">in</span> </span><br><span class="line">a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 传给函数</span></span><br><span class="line">operateOnNumbers(<span class="number">4</span>, <span class="number">2</span>, operation: addClosure) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>因为闭包就是没有名字的函数，所以，给 operateOnNumbers 传个函数一样可以正常运行：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addFunction</span><span class="params">(<span class="number">_</span> a: Int, <span class="number">_</span> b: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line">operateOnNumbers(<span class="number">4</span>, <span class="number">2</span>, operation: addFunction) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><ul><li>作为函数参数的时候可以使用内联闭包，就是直接将闭包传给函数参数，而不需要将闭包赋给一个变量。所以使用内联闭包的时候，上面的代码可以写成：</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">operateOnNumbers(<span class="number">4</span>, <span class="number">2</span>, operation: &#123; (a: <span class="type">Int</span>, b: <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>再考虑到上面已经讲过的一些书写闭包的语法糖，现在调用 operateOnNumbers 的时候仍然适用：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 闭包只有一句 return 语句时，可以省略 return 关键字</span></span><br><span class="line">operateOnNumbers(<span class="number">4</span>, <span class="number">2</span>, operation: &#123; (a: <span class="type">Int</span>, b:<span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">a + b</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 2. 已知闭包类型的情况下，省略参数和返回值类型</span></span><br><span class="line">operateOnNumbers(<span class="number">4</span>, <span class="number">2</span>, operation: &#123; (a, b) <span class="keyword">in</span></span><br><span class="line">a + b</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 3. 省略参数列表</span></span><br><span class="line">operateOnNumbers(<span class="number">4</span>, <span class="number">2</span>, operation: &#123; </span><br><span class="line">$<span class="number">0</span> + $<span class="number">1</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>除了上面的几种写法以外，还可以直接传给函数一个 ‘+’ 运算符，因为 ‘+’ 运算符本身也是函数，它接收两个参数，并返回其计算结果。所以，还可以写成下面的样子：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">operateOnNumbers(<span class="number">4</span>, <span class="number">2</span>, operation: +)</span><br></pre></td></tr></table></figure><p>上面的写法已经非常简单明白了，但是还可以进一步优化。当闭包是函数的<strong>最后一个参数</strong>的时候，可以将闭包写在函数的后面，这种写法也称为<strong>尾随闭包( trailing closure)</strong>。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 普通写法</span></span><br><span class="line">operateOnNumbers(<span class="number">4</span>, <span class="number">2</span>, operation: &#123; </span><br><span class="line">$<span class="number">0</span> + $<span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 2. 使用尾随闭包的写法</span></span><br><span class="line">operateOnNumbers(<span class="number">4</span>, <span class="number">2</span>) &#123;</span><br><span class="line">  $<span class="number">0</span> + $<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Closures-with-no-return-value"><a href="#Closures-with-no-return-value" class="headerlink" title="Closures with no return value"></a>Closures with no return value</h2><p>目前为止，上面的闭包都接收了至少一个参数并且有返回值，但是和函数一样，参数和返回值并不是必需的，闭包可以没有参数也没有返回值，而只完成某一特定的操作。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个闭包voidClosure，voidClosure没有参数也没有返回值</span></span><br><span class="line"><span class="keyword">let</span> voidClosure: () -&gt; <span class="type">Void</span> = &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"This is a closure"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">voidClosure()</span><br></pre></td></tr></table></figure><h2 id="Capturing-from-enclosing-scope"><a href="#Capturing-from-enclosing-scope" class="headerlink" title="Capturing from enclosing scope"></a>Capturing from enclosing scope</h2><p>最后，回到闭包的特性上来，开篇就强调了，闭包之所以叫“闭包”，是因为它可以捕获作用域内的值。即使定义这些常量和变量的原作用域已经不存在，闭包仍然可以在闭包函数体内引用和修改这些值。举个例子：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line"><span class="comment">// incrementCounter是一个闭包，因为闭包和变量counter作用域相同，所以可以捕获变量，并在闭包内使用</span></span><br><span class="line"><span class="keyword">let</span> incrementCounter = &#123;</span><br><span class="line">  counter += <span class="number">1</span> <span class="comment">// 闭包内增加counter的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 然后多次调用闭包</span></span><br><span class="line">incrementCounter() <span class="comment">// 1</span></span><br><span class="line">incrementCounter() <span class="comment">// 2</span></span><br><span class="line">incrementCounter() <span class="comment">// 3</span></span><br><span class="line">incrementCounter() <span class="comment">// 4</span></span><br><span class="line">incrementCounter() <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>上面的例子只是简单演示了闭包对变量的捕获，现在定义一个函数，函数的返回值是一个闭包：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countingClosure</span><span class="params">()</span></span> -&gt; (() -&gt; <span class="type">Int</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> incrementCounter: () -&gt; <span class="type">Int</span> = &#123;</span><br><span class="line">    counter += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> counter</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将闭包返回</span></span><br><span class="line">  <span class="keyword">return</span> incrementCounter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counter1 = countingClosure() </span><br><span class="line"><span class="keyword">let</span> counter2 = countingClosure() </span><br><span class="line">counter1() <span class="comment">// 1</span></span><br><span class="line">counter2() <span class="comment">// 1</span></span><br><span class="line">counter1() <span class="comment">// 2</span></span><br><span class="line">counter1() <span class="comment">// 3</span></span><br><span class="line">counter2() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面的结果表示在两个闭包内部对 counter 的操作是连续和各自独立的。</p><h2 id="Closures-are-reference-types"><a href="#Closures-are-reference-types" class="headerlink" title="Closures are reference types"></a>Closures are reference types</h2><p>在上面的例子中，counter1 和 counter2 都被声明为常量，但是 counter1 和 counter2 仍然可以改变闭包中 counter 变量的值，这是因为函数和闭包都是<strong>引用类型 (reference type)</strong>，当把一个闭包赋给一个变量或者常量的时候，实际上是将变量或常量指向这个闭包所在的地址。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意上面的代码，counter1中的counter当前值是3</span></span><br><span class="line"><span class="keyword">let</span> counter3 = counter1 </span><br><span class="line">counter3() <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><h2 id="Escaping-closures"><a href="#Escaping-closures" class="headerlink" title="Escaping closures"></a>Escaping closures</h2><p>一个闭包作为参数传到一个函数中，但是这个闭包在函数返回之后才被执行，我们称该闭包从函数中逃逸。默认情况下闭包是不允许“逃逸”出函数的，标记为 <strong>@escape</strong>才表示允许闭包在函数返回后执行。将闭包标注 <strong>@escape</strong> 能使编译器知道这个闭包的生命周期。</p><p>非逃逸闭包和逃逸闭包讲的并不是执行的先后顺序，非逃逸闭包指的是闭包不可以在函数外单独调用，只能在函数内部调用，函数调用完成后，这个闭包就结束了。</p><p>将一个闭包标记为允许逃逸时，在闭包内部访问<strong>实例变量</strong>时要使用 self，而不允许闭包逃逸的时候，访问变量不需要使用 self。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个存放函数的数组</span></span><br><span class="line"><span class="keyword">var</span> completionHandlers: [() -&gt; <span class="type">Void</span>] = []</span><br><span class="line"><span class="comment">// 定义一个接收闭包参数的函数，闭包允许逃逸</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunctionWithEscapingClosure</span><span class="params">(completionHandler: @escaping <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">  completionHandlers.append(completionHandler)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunctionWithNonescapingClosure</span><span class="params">(closure: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">  closure()</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">10</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">    someFunctionWithEscapingClosure &#123; <span class="keyword">self</span>.x = <span class="number">100</span> &#125;</span><br><span class="line">    someFunctionWithNonescapingClosure &#123; x = <span class="number">200</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = <span class="type">SomeClass</span>()</span><br><span class="line">instance.doSomething()</span><br><span class="line"><span class="built_in">print</span>(instance.x) <span class="comment">// prints "200"</span></span><br><span class="line"></span><br><span class="line">completionHandlers.first?() <span class="comment">// 延迟调用</span></span><br><span class="line"><span class="built_in">print</span>(instance.x) <span class="comment">// prints "100"</span></span><br></pre></td></tr></table></figure><h2 id="Autoclosures"><a href="#Autoclosures" class="headerlink" title="Autoclosures"></a>Autoclosures</h2><p>我们都知道 <strong>&amp;&amp;</strong> 是个短路运算符，它有两个操作数，首先会计算左边的操作数是不是 true，只有当左边操作数是 true 的时候，才会计算右边的操作数。假如左边是 false，整个表达式的值就是 false，所以无需计算右边的表达式。假如，我们要对数组的第一个元素进行某种判断，可以使用下面的代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> evens = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">if</span> !evens.isEmpty &amp;&amp; evens[<span class="number">0</span>] &gt; <span class="number">10</span> &#123;</span><br><span class="line">  evens[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这主要依赖于 &amp;&amp; 运算符的短路机制，否则 evens 为空的时候程序就会崩溃。虽然几乎所有语言的 &amp;&amp; 和 || 运算符都有内建的短路机制，但是如何给自定义的运算符添加短路机制呢。假如我们使用下面的代码实现 &amp;&amp; 运算符：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">and</span><span class="params">(<span class="number">_</span> l: Bool, <span class="number">_</span> r: Bool)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">  <span class="keyword">guard</span> l <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">  <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的 and 并不具备短路机制。因为被传入的参数 r 是 Bool 类型，在 and 内部已经得到了结果。我们要想把这个判断过程延迟，只要在左边表达式为 true 的时候才进行。这就可以使用闭包来满足需求，因为闭包可以把真正执行的代码封装到一个变量中并延迟执行。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">and</span><span class="params">(<span class="number">_</span> l: Bool, <span class="number">_</span> r: <span class="params">()</span></span></span> -&gt; <span class="type">Bool</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">  <span class="keyword">guard</span> l <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">  <span class="keyword">return</span> r()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样调用 and 的时候就可以使用下面的代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> and(!evens.isEmpty, &#123;evens[<span class="number">0</span>] &gt; <span class="number">10</span>&#125;) &#123;</span><br><span class="line">  evens[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与 &amp;&amp; 运算符相比，在 and 方法中，第二个参数变成了闭包，但我们真正关心的只是代码中的内容，使用闭包带来了便利却也使书写变得麻烦。这时候就可以使用 <strong>@autoclosure</strong> 关键字了，它可以把一个表达式自动变成闭包的形式。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">and</span><span class="params">(<span class="number">_</span> l: Bool, @autoclosure <span class="number">_</span> r: <span class="params">()</span></span></span> -&gt; <span class="type">Bool</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">  <span class="keyword">guard</span> l <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">  <span class="keyword">return</span> r()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是 and 方法的调用就可以简化为下面的样子：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> and(!evens.isEmpty, evens[<span class="number">0</span>] &gt; <span class="number">10</span>) &#123;</span><br><span class="line">  evens[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了可以用于短路运算符以外，@autoclosure 关键字在一些调试、日志函数中也很有用处，比如我们可以看到在 <em>fatalError</em> 和 <em>assert</em> 函数的定义中也用到了 @autoclosure 关键字。以 <em>assert</em> 函数为例，它只在调试的时候才会触发，因此在 release 模式下，闭包内的代码不会执行，这样有助于提高程序的效率。</p><h2 id="Custom-sorting-with-closures"><a href="#Custom-sorting-with-closures" class="headerlink" title="Custom sorting with closures"></a>Custom sorting with closures</h2><p>在 collection 类型中有一个 sorted 函数用于进行对 collection 中的元素进行排序，使用闭包，可以实现自定义排序规则。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> names = [<span class="string">"ZZZZZZ"</span>, <span class="string">"BB"</span>, <span class="string">"A"</span>, <span class="string">"CCCC"</span>, <span class="string">"EEEEE"</span>]</span><br><span class="line">names.sorted() <span class="comment">// ["A", "BB", "CCCC", "EEEEE", "ZZZZZZ"]</span></span><br></pre></td></tr></table></figure><p>默认是根据字母表的顺序排列的，现在我们将其改成根据字符串的长度进行排序：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sorted 有一个参数接收一个用于定义排序规则的闭包</span></span><br><span class="line">names.sorted &#123;</span><br><span class="line">  $<span class="number">0</span>.characters.<span class="built_in">count</span> &gt; $<span class="number">1</span>.characters.<span class="built_in">count</span> <span class="comment">// 根据字符串长度排序</span></span><br><span class="line">&#125; <span class="comment">// ["ZZZZZZ", "EEEEE", "CCCC", "BB", "A"]</span></span><br></pre></td></tr></table></figure><h2 id="Iterating-over-collections-with-closures"><a href="#Iterating-over-collections-with-closures" class="headerlink" title="Iterating over collections with closures"></a>Iterating over collections with closures</h2><p>Swift 的 collection 类型实现了很多简单的语法，而实现过程大多依赖函数式编程，并且使用了闭包。这里介绍一下常用的3个函数：filter，map 和 reduce。</p><ul><li>函数 filter 允许自定义规则对 collection 中的元素进行筛选。</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> prices = [<span class="number">1</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">20</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> largePrices = prices.<span class="built_in">filter</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> $<span class="number">0</span> &gt; <span class="number">5</span> <span class="comment">// 大于5的元素会被筛选出来，筛选条件是一个Bool表达式</span></span><br><span class="line">&#125; <span class="comment">// [10, 8, 20]</span></span><br></pre></td></tr></table></figure><ul><li>函数 map 允许对 collection 中的所有元素分别执行某个操作。</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> prices = [<span class="number">1</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">20</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> salePrices = prices.<span class="built_in">map</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> $<span class="number">0</span> - <span class="number">1</span> <span class="comment">// prices中的每个元素依次减少1</span></span><br><span class="line">&#125; <span class="comment">// [0, 9, 7, 19, 2]</span></span><br></pre></td></tr></table></figure><ul><li>函数 reduce 可以对 collection 中的元素依次迭代执行某个操作。</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stock = [<span class="number">1.5</span>: <span class="number">5</span>, <span class="number">10</span>: <span class="number">2</span>, <span class="number">4.99</span>: <span class="number">20</span>, <span class="number">2.30</span>: <span class="number">5</span>, <span class="number">8.19</span>: <span class="number">30</span>]</span><br><span class="line"><span class="keyword">let</span> stockSum = stock.<span class="built_in">reduce</span>(<span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> $<span class="number">0</span> + $<span class="number">1</span>.key * <span class="type">Double</span>($<span class="number">1</span>.value)</span><br><span class="line">&#125; <span class="comment">// 384.5</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> swift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Optionals in Swift</title>
      <link href="/cactus-dark/2016/11/22/Optionals-in-Swift/"/>
      <url>/cactus-dark/2016/11/22/Optionals-in-Swift/</url>
      <content type="html"><![CDATA[<p>Swift 中有一种实用也很容易迷惑的特性<strong>可选类型 (Optional)</strong>，所谓的 Optional 就是一个变量或者常量，这个变量或常量可以有值，也可以为 nil，只能为这两种情况。相当于有一个盒子，盒子只有两种状态，盒子中有个物体或者盒子为空，不管盒子中有没有物体，盒子一直都存在。</p><h2 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h2><p>声明一个可选类型的变量只需要在类型后面使用<strong>问号 (?)</strong>，如果声明了一个 optional 类型的变量，并且没有为其赋初值，那么 optional 会被自动设置为 nil。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result: <span class="type">Int</span>? = <span class="number">30</span> <span class="comment">// result要么包含一个Int值，要么为nil</span></span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment">// Optional(30)</span></span><br><span class="line">result = <span class="literal">nil</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="Unwrapping-optionals"><a href="#Unwrapping-optionals" class="headerlink" title="Unwrapping optionals"></a>Unwrapping optionals</h2><p>如果确定一个 optional 有值，那么可以使用<strong>叹号 (!)</strong>来获取optional的值，这个过程称为<strong>可选值的解包 (unwrapping optionals)</strong>。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result: <span class="type">Int</span>? = <span class="number">30</span></span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment">// Optional(30)</span></span><br><span class="line"><span class="comment">// 如果要改变result的值，必须先将result解包</span></span><br><span class="line"><span class="built_in">print</span>(result + <span class="number">1</span>) <span class="comment">// error: value of type 'Int?' not unwrapped</span></span><br></pre></td></tr></table></figure><p>将一个可选值进行解包，通常有两种方法，一种是在确定 optional 有值的情况下，使用叹号 (!) 进行<strong>强制解包 (force unwrapping)</strong>。比如上面要获取 result 的值，就可以使用下面的代码实现。    </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> unwrappedResult = result! </span><br><span class="line"><span class="built_in">print</span>(unwrappedResult) <span class="comment">// 30</span></span><br></pre></td></tr></table></figure><p>但是如果不小心对一个为 nil 的可选值进行强制解包就会导致错误，而且这种错误在编译时期并不一定能被发现。所以就有了另一种对可选值的处理方式：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> result != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"result is <span class="subst">\(result!)</span>"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"result is nil"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 if 语句首先检查 optional 中是否包含一个值，然后再进行对应的处理。这种代码在一定程度上可以保证程序运行的安全，但是仍然不完美，因为在使用的时候需要时刻对可选值进行检查。</p><h2 id="Optional-binding"><a href="#Optional-binding" class="headerlink" title="Optional binding"></a>Optional binding</h2><p><strong>可选值绑定 (optional binding)</strong>是为了安全的访问 optional 中的值而出现的。进行可选绑定的时候，可以使用 let 也可以使用 var。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> unwrappedResult = result &#123; <span class="comment">// 注意result后面并没有叹号(!)</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"result is <span class="subst">\(unwrappedResult)</span>"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"result is nil"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如 result 有值，上面的代码会将 result 解包并赋给 unwrappedResult，然后在需要使用 result 的地方就可以使用 unwrappedResult 代替。通常情况下的写法是下面这样的，并不需要为解包后的 optional 特意取个新的变量名。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> result = result &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"result is <span class="subst">\(result)</span>"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"result is nil"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如有多个可选值，还可以同时进行多个可选绑定操作，只有当多个 optional 都有值的时候，if 后面的代码才会被执行。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> authorName: <span class="type">String</span>? = <span class="string">"James"</span></span><br><span class="line"><span class="keyword">var</span> authorAge: <span class="type">Int</span>? = <span class="number">30</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> authorName = authorName, <span class="keyword">let</span> authorAge = authorAge &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"The author is <span class="subst">\(authorName)</span> who is <span class="subst">\(authorAge)</span> years old"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"No author or no age"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 此外，在可选绑定操作的后面还可以添加额外的判断条件。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> authorName: <span class="type">String</span>? = <span class="string">"James"</span></span><br><span class="line"><span class="keyword">var</span> authorAge: <span class="type">Int</span>? = <span class="number">30</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> authorName = authorName, <span class="keyword">let</span> authorAge = authorAge, authorAge &gt;= <span class="number">40</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"The author is <span class="subst">\(authorName)</span> who is <span class="subst">\(authorAge)</span> years old"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"No author or no age or no age less than 40"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Implicitly-unwrapped-optionals"><a href="#Implicitly-unwrapped-optionals" class="headerlink" title="Implicitly unwrapped optionals"></a>Implicitly unwrapped optionals</h2><p>有的时候，从程序的结构上来讲，一个可选值在初始化以后便不会再为 nil，在这些情况下，使用可选值的时候假如仍然需要使用叹号 (!) 进行解包就显得非常多余。这个时候就可以使用<strong>隐式解包的可选值 (implicity unwrapped optionals)</strong>。隐式解包可选值在声明时使用叹号而非问号，使用的时候直接使用，不需要进行强制解包，因为其值不会为 nil，但是假如不小心将隐式解包的可选值赋为了 nil，在访问的时候就会触发运行时错误。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// an optional</span></span><br><span class="line"><span class="keyword">let</span> possibleString: <span class="type">String</span>? = <span class="string">"An optional string"</span></span><br><span class="line"><span class="comment">// access an optional</span></span><br><span class="line"><span class="keyword">let</span> forcedString: <span class="type">String</span> = possibleString! <span class="comment">// 需要叹号</span></span><br><span class="line"><span class="comment">// an implicitly unwrapped optional</span></span><br><span class="line"><span class="keyword">let</span> assumedString: <span class="type">String</span>! = <span class="string">"An implicitly unwrapped optional"</span></span><br><span class="line"><span class="keyword">let</span> implicitString: <span class="type">String</span> = assumedString <span class="comment">// 不需要叹号</span></span><br></pre></td></tr></table></figure><p>当然，仍然可以像使用普通可选值那样来使用隐式解包的可选值，比如使用 if 语句判断是否为空，使用可选绑定等。</p><h2 id="Nil-coalescing"><a href="#Nil-coalescing" class="headerlink" title="Nil coalescing"></a>Nil coalescing</h2><p>还有一种处理 optional 的方式，就是这儿介绍的 <strong>nil coalescing</strong>。考虑到一种情况，假如使用 optional 的时候，无论何时对 optional 进行解包都希望得到一个结果，不管可选值是不是 nil，这种情况下就可以设置一个默认值，当可选值为 nil 的时候，表达式就返回这个设定的默认值。设置默认值的语法是使用两个连续的问号 (??)。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> optionalInt: <span class="type">Int</span>? = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> mustHaveResult = optionalInt ?? <span class="number">0</span></span><br></pre></td></tr></table></figure><p>上面的表达式首先会判断 optionalInt 是不是 nil，optionalInt 不为 nil，就返回 optional的值，否则返回默认值0。上面的表达式等同于下面的语句，只是书写更加简洁。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> optionalInt: <span class="type">Int</span>? = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> mustHaveResult: <span class="type">Int</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> unwrapped = optionalInt &#123;</span><br><span class="line">  mustHaveResult = unwrapped</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  mustHaveResult = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Nested-optional"><a href="#Nested-optional" class="headerlink" title="Nested optional"></a>Nested optional</h2><p>可选值是可以进行嵌套的，但是可读性太差，使用的地方并不多，仅作为了解，比如下面的代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> number: <span class="type">Int</span>??? = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(number) <span class="comment">// Optional(Optional(Optional(10)))</span></span><br><span class="line"><span class="built_in">print</span>(number!) <span class="comment">// Optional(Optional(10))</span></span><br><span class="line"><span class="built_in">print</span>(number!!) <span class="comment">// Optional(10)</span></span><br><span class="line"><span class="built_in">print</span>(number!!!) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><h2 id="Guard"><a href="#Guard" class="headerlink" title="Guard"></a>Guard</h2><p><strong>guard</strong> 语句其实并不是 optional 的内容，但是考虑到 optional 中可能会经常使用到 guard 语句，所以在这里进行介绍。有的时候，在进行条件判断的时候，可能会期望只有判断条件为真的时候，代码才会执行，这时候就可以使用 guard 语句。考虑到有下面一个计算平面图形有几条边的函数：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculateNumberOfSides</span><span class="params">(shape: String)</span></span> -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">  <span class="keyword">switch</span> shape &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Triangle"</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Square"</span>, <span class="string">"Rectangle"</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Pentagon"</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Hexagon"</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">6</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数根据输入的图形的名字，返回图形边的数目，假如名字不正确则返回 nil，所以函数的返回值是可选值。可以在下面的代码中使用上面的函数：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maybePrintSides</span><span class="params">(shape: String)</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> sides = calculateNumberOfSides(shape: shape) <span class="comment">// sides is an optional</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> sides = sides &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"A <span class="subst">\(shape)</span> has <span class="subst">\(sides)</span> sides"</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"I don't know the number of sides for <span class="subst">\(shape)</span>"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码没有问题，可以正常的运行。相同的逻辑还可以使用 guard 语句，如下所示：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maybePrintSides</span><span class="params">(shape: String)</span></span> &#123;</span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> sides = calculateNumberOfSides(shape: shape) <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"I don't know the number of sides for <span class="subst">\(shape)</span>"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="comment">// else中一定要return</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"A <span class="subst">\(shape)</span> has <span class="subst">\(sides)</span> sides"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>guard 关键字跟 if 类似，后面可以接判断条件，也可以是可选绑定，紧接着后面是 else 代码块处理条件不满足的情况，并且记得 return，然后 else 代码块后面是处理条件成立时候的语句。</p>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> swift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Structs and Classes in Swift</title>
      <link href="/cactus-dark/2016/11/21/Structs-and-Classes-in-Swift/"/>
      <url>/cactus-dark/2016/11/21/Structs-and-Classes-in-Swift/</url>
      <content type="html"><![CDATA[<p>在 Swift 中<strong>结构体 (struct)</strong> 和<strong>类 (class)</strong> 有很多相似的地方，也有一些不同之处，下面记录并总结。内容主要参考了 <em>Swift Apprentice</em>。</p><h2 id="Struct"><a href="#Struct" class="headerlink" title="Struct"></a>Struct</h2><h3 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h3><p>Struct 作为一种常见的数据类型，在许多编程语言中都存在。我们使用 Struct 封装特定的数据结构。Swift 中赋予了 Struct 很多特性，比如 Struct 中除了可以定义属性外，还可以定义<strong>方法 (method)</strong> 和<strong>构造函数 (initializer)</strong>。</p><p>举个例子，为了表示在平面坐标系中的位置，定义一个结构体 Location, 其中包括两个属性 x 和 y。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Location</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">var</span> y: <span class="type">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就定义了一个结构体，然后就可以实例化以后使用，假如你没有实现  <strong>init</strong> 方法的话，结构体可以根据属性自动产生一个构造器:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> location = <span class="type">Location</span>(x: <span class="number">2</span>, y: <span class="number">4</span>)</span><br><span class="line"><span class="comment">// 使用点运算符访问</span></span><br><span class="line"><span class="built_in">print</span>(location.x) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">print</span>(location.y) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>现在为 Location 增加一个方法用于计算距离坐标原点的距离。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Location</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">var</span> y: <span class="type">Int</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">distanceToOrigin</span><span class="params">()</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="type">Double</span>(<span class="keyword">self</span>.x)</span><br><span class="line">    <span class="keyword">let</span> y = <span class="type">Double</span>(<span class="keyword">self</span>.y)</span><br><span class="line">    <span class="keyword">return</span> sqrt(x * x + y * y)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用结构体中的方法</span></span><br><span class="line"><span class="keyword">var</span> location = <span class="type">Location</span>(x: <span class="number">3</span>, y: <span class="number">4</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="built_in">distance</span> = location.distanceToOrigin() <span class="comment">// 点运算符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">distance</span>) <span class="comment">// 5.0</span></span><br></pre></td></tr></table></figure><h3 id="Value-type"><a href="#Value-type" class="headerlink" title="Value type"></a>Value type</h3><p>Struct 是<strong>值类型 (value type)</strong>, 所以 Struct 在传递的时候拷贝的是<strong>值</strong>, 而不是<strong>引用</strong>。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> location1 = <span class="type">Location</span>(x: <span class="number">3</span>, y: <span class="number">4</span>)</span><br><span class="line"><span class="keyword">var</span> location2 = location1</span><br><span class="line">location1.x = <span class="number">4</span> <span class="comment">// 更改 location1</span></span><br><span class="line"><span class="built_in">print</span>(location1.x) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">print</span>(location2.x) <span class="comment">// 3, location2 的值不变，说明两个实例分别占用的不是同一块内存</span></span><br></pre></td></tr></table></figure><h3 id="Extensions"><a href="#Extensions" class="headerlink" title="Extensions"></a>Extensions</h3><p>可以通过<strong>扩展 (extensions)</strong> 给一个结构体追加方法或者计算属性，但是不可以追加存储属性。此外，还可以在扩展中实现自定义的 <strong>init</strong> 方法，在扩展中实现的 <strong>init</strong> 方法将不会使结构体根据属性自动生成的 <strong>init</strong> 失效。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Location</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> gradient: <span class="type">Double</span> &#123; <span class="comment">// 追加一个计算属性来获取斜率</span></span><br><span class="line">    <span class="keyword">let</span> y = <span class="type">Double</span>(<span class="keyword">self</span>.y)</span><br><span class="line">    <span class="keyword">let</span> x = <span class="type">Double</span>(<span class="keyword">self</span>.x)</span><br><span class="line">    <span class="keyword">guard</span> x != <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y / x</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">init</span>() &#123;</span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    y = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> location1 = <span class="type">Location</span>() <span class="comment">// 使用自定义的 init</span></span><br><span class="line"><span class="keyword">var</span> location2 = <span class="type">Location</span>(x: <span class="number">3</span>, y: <span class="number">4</span>) <span class="comment">// 使用自动生成的 init</span></span><br></pre></td></tr></table></figure><h3 id="Conform-to-protocols"><a href="#Conform-to-protocols" class="headerlink" title="Conform to protocols"></a>Conform to protocols</h3><p>Struct 可以遵守<strong>协议 (protocols)</strong> 并实现协议中定义的属性或方法。下面遵守协议并实现 <strong>description</strong> 的过程如下:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Location</span>: <span class="title">CustomStringConvertible</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">var</span> y: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"location at (<span class="subst">\(x)</span>,<span class="subst">\(y)</span>)."</span>  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">distanceToOrigin</span><span class="params">()</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="type">Double</span>(<span class="keyword">self</span>.x)</span><br><span class="line">    <span class="keyword">let</span> y = <span class="type">Double</span>(<span class="keyword">self</span>.y)</span><br><span class="line">    <span class="keyword">return</span> sqrt(x * x + y * y)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><h3 id="Basics-1"><a href="#Basics-1" class="headerlink" title="Basics"></a>Basics</h3><p>Swift中的类和结构体类似，也可以定义<strong>属性</strong>、<strong>方法</strong>、<strong>遵守协议</strong>。除此之外，类还拥有<strong>继承 (inheritance)</strong>、<strong>重写 (override)</strong>、<strong>多态 (polymorphism)</strong> 等结构体不具有的功能。</p><p>下面从实现一个 Person 类开始，Person 类中有两个存储属性和一个 <strong>init</strong> 方法，注意，class 并不会根据属性自动生成一个构造函数，所以必需手动实现 init 方法，假如没有提供，就会产生错误。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> firstName: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> lastName: <span class="type">String</span></span><br><span class="line">  <span class="keyword">init</span>(firstName: <span class="type">String</span>, lastName: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.firstName = firstName</span><br><span class="line">    <span class="keyword">self</span>.lastName = lastName</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> john = <span class="type">Person</span>(firstName: <span class="string">"Johnny"</span>, lastName: <span class="string">"Ivy"</span>)</span><br></pre></td></tr></table></figure><h3 id="Reference-type"><a href="#Reference-type" class="headerlink" title="Reference type"></a>Reference type</h3><p>在 Swift 中，结构体是一个<strong>不可变的值类型 (immutable value)</strong>, 而类则是<strong>可变的引用类型 (mutable reference)</strong>。所以即使类中的某个方法改变了类的内容，也不需要在方法前使用 <strong>mutating</strong> 关键字。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = <span class="type">Person</span>(firstName: <span class="string">"Bruce"</span>, lastName: <span class="string">"Lee"</span>)</span><br><span class="line"><span class="keyword">var</span> person2 = person1 <span class="comment">// 传递引用</span></span><br><span class="line"><span class="built_in">print</span>(person2.firstName) <span class="comment">// Bruce</span></span><br><span class="line">person1.firstName = <span class="string">"Jack"</span></span><br><span class="line"><span class="built_in">print</span>(person2.firstName) <span class="comment">// Jack</span></span><br></pre></td></tr></table></figure><p>若要比较两个对象指向的是不是同一块内存，可以使用 <strong>“===”</strong> 运算符，常用的 <strong>“==”</strong> 运算符只用于比较值是否相等。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = <span class="type">Person</span>(firstName: <span class="string">"Bruce"</span>, lastName: <span class="string">"Lee"</span>)</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="type">Person</span>(firstName: <span class="string">"Bruce"</span>, lastName: <span class="string">"Lee"</span>) <span class="comment">// person2和person1名字相同，是同一个人?</span></span><br><span class="line"><span class="keyword">var</span> person3 = person1 <span class="comment">// person3 和 person1 指向同一块内存</span></span><br><span class="line"><span class="built_in">print</span>(person1 === person2) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">print</span>(person1 === person3) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>因为对象是引用类型，所以即使将一个对象声明为常量，也可以改变对象中属性的值。常量表示对象指向内存的位置不可变，但是内存中存储的内容可以改变。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="type">Person</span>(firstName: <span class="string">"Bruce"</span>, lastName: <span class="string">"Lee"</span>) <span class="comment">// person为常量</span></span><br><span class="line">person.firstName = <span class="string">"Jack"</span> <span class="comment">// 更改 person 的属性</span></span><br><span class="line"><span class="built_in">print</span>(person.firstName) <span class="comment">// Jack, 属性的值仍然被改变了</span></span><br></pre></td></tr></table></figure><h3 id="Extensions-1"><a href="#Extensions-1" class="headerlink" title="Extensions"></a>Extensions</h3><p>与结构体类似，类也可以通过 extension 添加方法和计算属性。假如要添加一个计算属性 fullName, 实现如下：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fullName: <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"<span class="subst">\(firstName)</span> <span class="subst">\(lastName)</span>"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h3><p><strong>继承 (inheritance)</strong> 可以实现类的扩展，为已存在的类增加新的属性和方法，或者对原有的方法进行<strong>重写 (override)</strong>。</p><p>假如有一个 Student 类，定义如下:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Grade</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> letter: <span class="type">String</span></span><br><span class="line">  <span class="keyword">let</span> points: <span class="type">Double</span></span><br><span class="line">  <span class="keyword">let</span> credits: <span class="type">Double</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> firstName: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> lastNameL: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> grades: [<span class="type">Grade</span>] = [] <span class="comment">// 表示成绩</span></span><br><span class="line">  <span class="keyword">init</span>(firstName: <span class="type">String</span>, lastName: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.firstName = firstName</span><br><span class="line">    <span class="keyword">self</span>.lastName = lastName</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">recordGrade</span><span class="params">(<span class="number">_</span> grade: Grade)</span></span> &#123;</span><br><span class="line">    grades.append(grade)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 Student 也是 Person, 所以可以在现有的 Person 类基础上进行扩展来减少代码冗余。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Grade</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> letter: <span class="type">String</span></span><br><span class="line">  <span class="keyword">let</span> points: <span class="type">Double</span></span><br><span class="line">  <span class="keyword">let</span> credits: <span class="type">Double</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> firstName: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> lastName: <span class="type">String</span></span><br><span class="line">  <span class="keyword">init</span>(firstName: <span class="type">String</span>, lastName: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.firstName = firstName</span><br><span class="line">    <span class="keyword">self</span>.lastName = lastName</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>: <span class="title">Person</span> </span>&#123; <span class="comment">// Student 继承自 Person</span></span><br><span class="line">  <span class="keyword">var</span> grades: [<span class="type">Grade</span>] = []</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">recordGrade</span><span class="params">(<span class="number">_</span> grade: Grade)</span></span> &#123;</span><br><span class="line">    grades.append(grade)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过继承，Student 拥有了 Person 的属性、构造函数和其它的方法。然后就可以像使用 Person 一样使用 Student。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> john = <span class="type">Person</span>(firstName: <span class="string">"Johnny"</span>, lastName: <span class="string">"Ivy"</span>)</span><br><span class="line"><span class="keyword">let</span> jane = <span class="type">Student</span>(firstName: <span class="string">"Jane"</span>, lastName: <span class="string">"Ivy"</span>)</span><br><span class="line"><span class="built_in">print</span>(john.firstName) <span class="comment">// Johnny</span></span><br><span class="line"><span class="built_in">print</span>(jane.firstName) <span class="comment">// Jane</span></span><br></pre></td></tr></table></figure><p>除了继承自 Person 的属性和方法外，Student 还有自身的属性 <strong>grades</strong> 和方法，而特有的属性和方法只有 Student 的实例才可以访问。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> history = <span class="type">Grade</span>(letter: <span class="string">"B"</span>, points: <span class="number">9.0</span>, credits: <span class="number">3.0</span>)</span><br><span class="line">jane.recordGrade(history)</span><br><span class="line">john.recordGrade(history) <span class="comment">// Error: john is not a student</span></span><br></pre></td></tr></table></figure><p>Swift 中的类不支持多继承，一个子类最多允许继承自一个父类。</p><h3 id="Polymorphism"><a href="#Polymorphism" class="headerlink" title="Polymorphism"></a>Polymorphism</h3><p><strong>多态 (Polymorphism)</strong> 是许多面向对象的语言的特性，使用多态可以写出更加抽象和灵活的代码，涉及到多态的时候，主要有两个重要的性质：</p><ul><li>父类的指针可以指向子类的对象</li><li>不同的对象作用于同一个方法会产生不同的响应</li></ul><p>下面仍然使用介绍 Objective-C 中多态的时候所用的例子来说明 Swift 中的多态。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="comment">// 定义一个基类 Animal, 计算属性用于获取动物的名字，方法用于描述动物被打了以后的反应</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">beBeaten</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Cat 继承自 Animal, 并重写了 beBeaten() 方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>: <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">beBeaten</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Bark and jump to high!"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Dog 继承自 Animal, 并重写了 beBeaten() 方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>: <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">beBeaten</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Give a hard bit!"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Frog 继承自 Animal, 并重写了 beBeaten() 方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Frog</span>: <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">beBeaten</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Do nothing!"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义一个 Human 类, 用于攻击 animala, 注意 beatAnimal(:) 的参数类型是 Animal, 并没有指明具体是哪种 Animal</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">beatAnimal</span><span class="params">(animal: Animal)</span></span> &#123;</span><br><span class="line">    animal.beBeaten()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> linda = <span class="type">Human</span>(name: <span class="string">"Linda"</span>)</span><br><span class="line"><span class="keyword">let</span> cat = <span class="type">Cat</span>()</span><br><span class="line"><span class="keyword">let</span> dog = <span class="type">Dog</span>()</span><br><span class="line"><span class="keyword">let</span> frog = <span class="type">Frog</span>()</span><br><span class="line"><span class="comment">// 同样的方法，作用于不同的对象，产生不同的响应</span></span><br><span class="line">linda.beatAnimal(animal: cat) <span class="comment">// Bark and jump to high!</span></span><br><span class="line">linda.beatAnimal(animal: dog) <span class="comment">// Give a hard bit!</span></span><br><span class="line">linda.beatAnimal(animal: frog) <span class="comment">// Do nothing!</span></span><br></pre></td></tr></table></figure><h3 id="Preventing-inheritance"><a href="#Preventing-inheritance" class="headerlink" title="Preventing inheritance"></a>Preventing inheritance</h3><p>假如有时候，存在某个类，这个类不可以被继承，或者是这个类中的某些方法不允许被重写，那么就可以使用 <strong>final</strong> 关键字，被指定为 <strong>final</strong> 的类不可以被继承，被指定为 <strong>final</strong> 的方法不允许被重写。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">beBeaten</span><span class="params">()</span></span> -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Human 类不可以被继承</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">beatAnimal</span><span class="params">(animal: Animal)</span></span> &#123;</span><br><span class="line">    animal.beBeaten()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span>: <span class="title">Human</span> </span>&#123; <span class="comment">// Error</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 被标记为 final 的方法或属性不可以被重写</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> <span class="function"><span class="keyword">func</span> <span class="title">beatAnimal</span><span class="params">(animal: Animal)</span></span> &#123;</span><br><span class="line">    animal.beBeaten()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span>: <span class="title">Human</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">beatAnimal</span><span class="params">(animal: Animal)</span></span> &#123; <span class="comment">// error</span></span><br><span class="line">    animal.beBeaten()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="Required-and-convenience-initializers"><a href="#Required-and-convenience-initializers" class="headerlink" title="Required and convenience initializers"></a>Required and convenience initializers</h3><p>一个类可以有多个构造函数，这意味着在子类中可以任意调用父类的构造函数来完成自身的初始化。通过给 <strong>init</strong> 方法标记 <strong>required</strong> 或者 <strong>convenience</strong> 关键字将其指定为指定构造函数或者便利构造函数。</p><ul><li>所有子类都必须实现父类的标记为 <strong>required</strong> 的构造函数，而且不需要使用 <strong>override</strong> 关键字。</li><li>一个指定构造函数必须调用直接父类的指定构造函数。</li><li>所有便利构造函数最终都要直接或间接调用自身的指定构造函数。</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> firstName: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> lastName: <span class="type">String</span></span><br><span class="line">  <span class="keyword">required</span> <span class="keyword">init</span>(firstName: <span class="type">String</span>, lastName: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.firstName = firstName</span><br><span class="line">    <span class="keyword">self</span>.lastName = lastName</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"I am a person"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">convenience</span> <span class="keyword">init</span>(person: <span class="type">Person</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.<span class="keyword">init</span>(firstName: person.firstName, lastName: person.lastName)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>: <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sports: [<span class="type">String</span>]</span><br><span class="line">  <span class="keyword">required</span> <span class="keyword">init</span>(firstName: <span class="type">String</span>, lastName: <span class="type">String</span>) &#123; <span class="comment">// 不需要 override 关键字，但需要 required 关键字以保证  Student 的子类也必须实现此方法</span></span><br><span class="line">    <span class="keyword">self</span>.sports = []</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"I am a student"</span>)</span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(firstName: firstName, lastName: lastName)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建两个实例</span></span><br><span class="line"><span class="keyword">var</span> denny = <span class="type">Student</span>(firstName: <span class="string">"Denny"</span>, lastName: <span class="string">"Green"</span>)</span><br><span class="line"><span class="keyword">var</span> ivy = <span class="type">Student</span>(person: denny)</span><br></pre></td></tr></table></figure><h3 id="Retain-cycle-and-weak-references"><a href="#Retain-cycle-and-weak-references" class="headerlink" title="Retain cycle and weak references"></a>Retain cycle and weak references</h3><p>同 Objective-C 中类似，Swift 也是使用 ARC 来进行内存管理，所以同样存在循环引用的问题，解决办法就是使用<strong>弱引用 (weak reference)</strong>。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> firstName: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> lastName: <span class="type">String</span></span><br><span class="line">  <span class="keyword">init</span>(firstName: <span class="type">String</span>, lastName: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.firstName = firstName</span><br><span class="line">    <span class="keyword">self</span>.lastName = lastName</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>: <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> partner: <span class="type">Student</span>?</span><br><span class="line">  <span class="keyword">deinit</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(firstName)</span> is deinited."</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> denny: <span class="type">Student</span>? = <span class="type">Student</span>(firstName: <span class="string">"Denny"</span>, lastName: <span class="string">"Green"</span>)</span><br><span class="line"><span class="keyword">var</span> jack: <span class="type">Student</span>? = <span class="type">Student</span>(firstName: <span class="string">"Jack"</span>, lastName: <span class="string">"Bush"</span>)</span><br><span class="line">denny?.partner = jack</span><br><span class="line">jack?.partner = denny</span><br><span class="line">denny = <span class="literal">nil</span></span><br><span class="line">jack = <span class="literal">nil</span> <span class="comment">// 即使 denny 和 jack 都变成 nil, 内存也没被释放，这就是因为产生了循环引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决办法是将 partner 改成 weak, swift 中的属性默认是 strong</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>: <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">weak</span> <span class="keyword">var</span> partner: <span class="type">Student</span>?</span><br><span class="line">  <span class="keyword">deinit</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(firstName)</span> is deinited."</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> swift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Properties in Swift</title>
      <link href="/cactus-dark/2016/11/20/Properties-in-Swift/"/>
      <url>/cactus-dark/2016/11/20/Properties-in-Swift/</url>
      <content type="html"><![CDATA[<p>最近读了<em><a href="https://store.raywenderlich.com/products/swift-apprentice" target="_blank" rel="noopener">Swift Apprentice</a></em>, 将其中一些关于 Property 的知识总结一下。主要包括以下几个部分:</p><ul><li>存储属性 (Stored Properties)</li><li>计算属性 (Computed Properties)</li><li>类型属性 (Typed Properties)</li><li>属性观察器 (Property Observers)</li><li>延迟加载属性 (Lazy Properties)</li></ul><a id="more"></a><p>在下面的例子中，结构体 Car 有两个属性，存储了两个字符串常量。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> make: <span class="type">String</span></span><br><span class="line">  <span class="keyword">let</span> color: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的属性称为<strong>存储属性 (Stored Property)</strong>, 表示它们将会为每个 Car 的实例开辟内存并且存储值。</p><p>除了存储属性外还有一种<strong>计算属性 (Computed Property)</strong>, 在创建实例的时候并不会为计算属性分配空间，而只是在需要的时候简单的计算它们的值。</p><h2 id="Stored-properties"><a href="#Stored-properties" class="headerlink" title="Stored properties"></a>Stored properties</h2><p>假如你想创建一个通讯录，那么通讯录中的每一条联系人的组成可能是下面这样:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Contact</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fullName: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> emailAddress: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Contact 中的属性并没有赋上初始值，所以只能通过<strong>构造函数 (initializer)</strong> 来实例化，Swift 会根据类型中的属性，自动生成一个构造函数。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="type">Contact</span>(fullName: <span class="string">"Grace Murray"</span>, emailAddress: <span class="string">"grace@navy.mil"</span>)</span><br></pre></td></tr></table></figure><p>实例化完成以后，就可以使用<strong>点运算符 (dot notation)</strong> 来访问实例中的属性:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = person.fullName <span class="comment">// Grace Murray</span></span><br><span class="line"><span class="keyword">let</span> email = person.emailAddress <span class="comment">// grace@navy.mil</span></span><br></pre></td></tr></table></figure><p>如果存储属性的结构体实例是变量，而且属性也是个变量，那么就可以给结构体的属性赋值，</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Grace got married so she changed her name</span></span><br><span class="line">person.fullName = <span class="string">"Grace Hopper"</span></span><br><span class="line"><span class="keyword">let</span> grade = person.fullName <span class="comment">// Grace Hopper</span></span><br></pre></td></tr></table></figure><p>如果一个属性在实例化以后不希望被改变的话，那么声明的时候可以使用 <strong>let</strong> 将其声明为常量。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Contact</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fullName: <span class="type">String</span></span><br><span class="line">  <span class="keyword">let</span> emailAddress: <span class="type">String</span> <span class="comment">// emailAddress 是个常量，实例化完成后就不可以再修改</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="type">Contact</span>(fullName: <span class="string">"Linda"</span>, emailAddress: <span class="string">"sb@baidu.com"</span>) <span class="comment">// 实例化</span></span><br><span class="line">person.emailAddress = <span class="string">"sb@sohu.com"</span> <span class="comment">// error: 不可以修改一个常量的值</span></span><br></pre></td></tr></table></figure><h3 id="Default-values"><a href="#Default-values" class="headerlink" title="Default values"></a>Default values</h3><p>如果一个属性的值是可以预测的，而且很少变动的话，那么可以给属性设置一个默认值。下面为 Contact 增加一个属性 type 用于标记联系人所属的分组。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Contact</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fullName: <span class="type">String</span></span><br><span class="line">  <span class="keyword">let</span> emailAddress: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> type = <span class="string">"Friend"</span> <span class="comment">// property with default value</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置默认值在一定程度上可以减少代码负担，缺点是 Swift 根据属性自动生成的构造函数中还需要指定 type 的值，除非你实现了一个自定义的构造函数</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="type">Contact</span>(fullName: <span class="string">"Linda"</span>, emailAddress: <span class="string">"sb@baidu.com"</span>, type: <span class="string">"Friend"</span>)</span><br></pre></td></tr></table></figure><h2 id="Computed-properties"><a href="#Computed-properties" class="headerlink" title="Computed properties"></a>Computed properties</h2><p><strong>存储属性</strong>既可以是常量也可以是变量，而<strong>计算属性</strong>只能是变量，而且必须明确指出属性的类型。</p><p>下面以 TV 为例说明，其中包括 3 个属性 height 、width 、diagonal 分别表示 TV 的高、宽和对角线长度。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TV</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> height: <span class="type">Double</span></span><br><span class="line">  <span class="keyword">var</span> width: <span class="type">Double</span></span><br><span class="line">  <span class="comment">// diagonal 为计算属性，必须指定其类型，而且只能声明为变量 (var)</span></span><br><span class="line">  <span class="keyword">var</span> diagonal: <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = sqrt(height * height + width * width)</span><br><span class="line">    <span class="keyword">let</span> roundedResult = result.rounded()</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Int</span>(roundedResult)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算属性不存储值，只是计算结果后返回</span></span><br><span class="line"><span class="keyword">var</span> tv = <span class="type">TV</span>(height: <span class="number">53.93</span>, width: <span class="number">95.87</span>)</span><br><span class="line"><span class="keyword">let</span> size = tv.diagonal <span class="comment">// 110</span></span><br></pre></td></tr></table></figure><p>上面的 diagonal 只有一个 <strong>getter</strong>, 还可以实现一个 <strong>setter</strong>, 因为计算属性不存储值，所以 <strong>setter</strong> 中一般是修改相关的存储属性的值。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> diagonal: <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">get</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = sqrt(height * height + width * width)</span><br><span class="line">    <span class="keyword">let</span> roundedResult = result.rounded()</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Int</span>(roundedResult)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> ratioWidth = <span class="number">16.0</span></span><br><span class="line">    <span class="keyword">let</span> ratioHeight = <span class="number">9.0</span></span><br><span class="line">    <span class="comment">// 修改 height 和 width</span></span><br><span class="line">    height = <span class="type">Double</span>(newValue) * ratioHeight /</span><br><span class="line">      sqrt(ratioWidth * ratioWidth + ratioHeight * ratioHeight)</span><br><span class="line">    width = height * ratioWidth / ratioHeight</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Type-properties"><a href="#Type-properties" class="headerlink" title="Type properties"></a>Type properties</h2><p>上面 TV 的存储属性 height、width 和计算属性 diagonal 都是属于 TV 的实例的，所以必须实例化以后才能使用。而类型属性是属于类型本身的，通过类型名进行访问。</p><p>假如有一个存在多个关卡的游戏，每一关都是一个 Level 实例，并且拥有一些属性。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Level</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> id: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">var</span> boss: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> unlocked: <span class="type">Bool</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> level1 = <span class="type">Level</span>(id: <span class="number">1</span>, boss: <span class="string">"Chameleon"</span>, unlocked: <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">let</span> level2 = <span class="type">Level</span>(id: <span class="number">2</span>, boss: <span class="string">"Squid"</span>, unlocked: <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>现在给 Level 增加一个属性 highsetLevel 用于标记已解锁的最高关卡。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Level</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">var</span> highestLevel = <span class="number">1</span> <span class="comment">// 使用 static 标记一个类型属性</span></span><br><span class="line">  <span class="keyword">let</span> id: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">var</span> boss: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> unlocked: <span class="type">Bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，highestLevel 是 Level 类型的属性，而不是 Level 实例的属性，所以访问的时候使用类型名直接进行访问。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Error: 不能通过实例访问类型属性</span></span><br><span class="line"><span class="keyword">let</span> highestLevel = level2.highestLevel</span><br><span class="line"><span class="comment">// Right: 只能使用类型名访问类型属性</span></span><br><span class="line"><span class="keyword">let</span> highestLevel = <span class="type">Level</span>.highestLevel</span><br></pre></td></tr></table></figure><h2 id="Property-observers"><a href="#Property-observers" class="headerlink" title="Property observers"></a>Property observers</h2><p>在实现  Level 的时候，正确的操作应该是当一个新的关卡解锁 (unlocked) 的时候，用于标记最高关卡的 highestLevel 属性也随之改变。所以可以通过 Swift 的<strong>属性观察器 (Property Observer)</strong> 来监测属性的变化。属性观察器包括两个方法 <strong>willSet</strong> 和 <strong>didSet</strong>, 两者只是调用的时机不同。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Level</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">var</span> highestLevel = <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> id: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">var</span> boss: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> unlocked: <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">didSet</span> &#123;</span><br><span class="line">    <span class="comment">// 当关卡已解锁，当前所在关卡大于已记录的最高关卡时，更新最高关卡的值</span></span><br><span class="line">      <span class="keyword">if</span> unlocked &amp;&amp; id &gt; <span class="type">Level</span>.highestLevel &#123;</span><br><span class="line">        <span class="type">Level</span>.highestLevel = id</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，当解锁新的关卡时，最高关卡的值就会自动更新。注意 <strong>willSet</strong> 和 <strong>didSet</strong> 并不会在初始化的时候被调用，只有在完成初始化以后，再更改属性的值，才会被调用。</p><h3 id="Limiting-a-variable"><a href="#Limiting-a-variable" class="headerlink" title="Limiting a variable"></a>Limiting a variable</h3><p>属性观察器还可以用来约束属性的值，当设置的值不符合要求时进行相应的处理。didSet 中有个 <strong>oldValue</strong> 表示改变之前的值，willSet 中有个 <strong>newValue</strong> 表示新的值。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LightBulb</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">let</span> maxCurrent = <span class="number">40</span></span><br><span class="line">  <span class="keyword">var</span> current = <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">didSet</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> current &gt; <span class="type">LightBulb</span>.maxCurrent &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Current too high, falling back to previous setting."</span>)</span><br><span class="line">        current = oldValue</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当设置不满足条件的时候，就会进行相应处理</span></span><br><span class="line"><span class="keyword">var</span> light = <span class="type">LightBulb</span>()</span><br><span class="line">light.current = <span class="number">50</span></span><br><span class="line"><span class="keyword">var</span> current = light.current <span class="comment">// 0</span></span><br><span class="line">light.current = <span class="number">40</span></span><br><span class="line">current = light.current <span class="comment">// 40</span></span><br></pre></td></tr></table></figure><h2 id="Lazy-properties"><a href="#Lazy-properties" class="headerlink" title="Lazy properties"></a>Lazy properties</h2><p>如果有一些属性，初始化的时候并不需要知道它们的值，而只在需要的时候才进行计算，就可以使用 <strong>Lazy Property</strong> 。下面定义一个结构体 Circle 进行说明。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">  <span class="built_in">lazy</span> <span class="keyword">var</span> pi = &#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="number">4.0</span> * atan(<span class="number">1.0</span> / <span class="number">5.0</span>)) - atan(<span class="number">1.0</span> / <span class="number">239.0</span>)) * <span class="number">4.0</span></span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="keyword">var</span> radius = <span class="number">0.0</span></span><br><span class="line">  <span class="keyword">var</span> circumference: <span class="type">Double</span> &#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">get</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> pi * radius * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 自定义了init</span></span><br><span class="line">  <span class="keyword">init</span> (radius: <span class="type">Double</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.radius = radius</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的结构体 Circle 中定义了一个 Lazy Property, 注意 Lazy Property 必须是一个变量 <strong>var</strong>, 上面的 pi 的计算是一个闭包，所以后面有一对小括号，当访问 pi 的值时，闭包会被立即调用。实例化 Circle 的时候，尽管 pi 是存储属性，但并不需要提供 pi 的值，pi 的值会在第一次被访问的时候计算并存储起来。与之对比，属性 circumference 是一个计算属性，每次访问它的值都需要计算。注意 circumference 属性的 <strong>getter</strong> 前有一个 <strong>mutating</strong> 关键字，因为在 <strong>getter</strong> 中使用了 pi, 在获取 circumference 的时候会导致 pi 被计算，而原来实例在初始化的时候并没有设置 pi 的值，所以实例发生了改变，从而需要 <strong>mutating</strong> 关键字。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> circle = <span class="type">Circle</span>(radius: <span class="number">5</span>) <span class="comment">// 实例化一个 Circle, 此时 pi 还没有被计算</span></span><br><span class="line"><span class="keyword">let</span> circumference = circle.circumference <span class="comment">// 31.42, 此时 pi 也有了值</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> swift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS中使用外部字体</title>
      <link href="/cactus-dark/2016/11/04/iOS%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%A4%96%E9%83%A8%E5%AD%97%E4%BD%93/"/>
      <url>/cactus-dark/2016/11/04/iOS%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%A4%96%E9%83%A8%E5%AD%97%E4%BD%93/</url>
      <content type="html"><![CDATA[<p>最近在 iOS 项目中使用到了外部字体，所以简单记录一下。使用外部静态字体基本上分为以下几个步骤：</p><p>1.将要使用的 ttf 或 otf 字体文件导入到项目中</p><p>2.在 info.plist 文件中使用 <strong>Fonts provided by application</strong> 配置字体的信息，如下图所示：</p><p><img src="https://foolpermi-blog-1254115483.cos.ap-chengdu.myqcloud.com/images/tips/iOS%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%A4%96%E9%83%A8%E5%AD%97%E4%BD%93_01.jpg" alt=""></p><p>3.在项目中使用以下代码设置字体，也可以直接在 xib 或者 storyboard 中选择导入的字体</p><a id="more"></a><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.label.font = [<span class="built_in">UIFont</span> fontWithName:<span class="string">@"Ubuntu-B"</span> size:<span class="number">16</span>];</span><br></pre></td></tr></table></figure><p>还可以使用以下代码打印所有可以的字体的信息：</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">NSString</span> *fontFamilyName <span class="keyword">in</span> [<span class="built_in">UIFont</span> familyNames]) &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"family: %@"</span>,fontFamilyName);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *fontName <span class="keyword">in</span> [<span class="built_in">UIFont</span> fontNamesForFamilyName:fontFamilyName]) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"fontName: %@"</span>, fontName);        </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"---------"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>4.假如以上设置完成以后，仍然没有预期的效果，那么请在 <strong>Build Phases</strong> 的 <strong>Copy Bundle Resources</strong>中添加导入的字体</p><p><img src="https://foolpermi-blog-1254115483.cos.ap-chengdu.myqcloud.com/images/tips/iOS%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%A4%96%E9%83%A8%E5%AD%97%E4%BD%93_02.jpg" alt=""></p>]]></content>
      
      <categories>
          
          <category> 知识小集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Autolayout总结</title>
      <link href="/cactus-dark/2016/03/10/Autolayout%E6%80%BB%E7%BB%93/"/>
      <url>/cactus-dark/2016/03/10/Autolayout%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h2 id="Autolayout"><a href="#Autolayout" class="headerlink" title="Autolayout"></a>Autolayout</h2><p>最近两天看了几篇博客，查了相关的文档，认真研究了一下 Autolayout。很难想象我自学 iOS 这么久一直都没有系统地研究 Autolayout。因此决定写个总结。随着苹果的产品线的扩展，屏幕尺寸越来越多，Autolayout 的出现就是为了解决不同尺寸的屏幕的适配问题，还有后来的 sizeclass 技术，有关 sizeclass 的使用将在另外的文章中进行描述。Autolayout 的实现方式有很多种，苹果最初的 API，之后的 VFL，storyboard 以及第三方的 Masonry。    </p><a id="more"></a>    <p>在此之前，先给 Autolayout 一个总结，这个总结将贯穿全文。</p><ul><li>Autolayout 里有两个词，<strong>约束</strong>和<strong>参照</strong></li><li>要想显示一个控件，需要知道两个东西，<strong>位置</strong>和<strong>尺寸</strong>，对应于以前 frame 的 origin 和 size</li><li>添加的约束不宜过多，当约束足以确定控件的<strong>位置</strong>和<strong>尺寸</strong>，就足够了</li><li><strong>约束</strong>就是对控件的大小或位置进行约束，<strong>参照</strong>就是以某个控件的位置进行约束，两者并没有明确的区别，它们都可以对控件的<strong>位置</strong>和<strong>尺寸</strong>起到作用</li><li>所有控件，都离不开<strong>位置</strong>和<strong>尺寸</strong>，Autolayout 就是干这个的，后面的例子以UIView为例</li></ul><h2 id="代码实现Autolayout"><a href="#代码实现Autolayout" class="headerlink" title="代码实现Autolayout"></a>代码实现Autolayout</h2><ul><li><p>先从一个简单的例子开始学习通过 Autolayout 代码来完成一个控件的<strong>位置</strong>和<strong>尺寸</strong></p></li><li><p>我要在界面的左下方放置一个宽高各为50的红色 View，它距离屏幕左边缘和下边缘距离都是20</p></li><li><p>在此之前先介绍一个方法</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  这个是系统默认添加约束的方法，它是NSLayoutConstraint的类方法</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*  @param view1      传入想要添加约束的控件</span></span><br><span class="line"><span class="comment">*  @param attr1      传入想要添加约束的方向，这个枚举值有很多，可以自己看看</span></span><br><span class="line"><span class="comment">*  @param relation   传入与约束值的关系，大于，等于还是小于</span></span><br><span class="line"><span class="comment">*  @param view2      传入被参照对象</span></span><br><span class="line"><span class="comment">*  @param attr2      传入被参照对象所被参照的方向，如顶部，左边，右边等等</span></span><br><span class="line"><span class="comment">*  @param multiplier 传入想要的间距倍数关系</span></span><br><span class="line"><span class="comment">*  @param c          传入最终的差值</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*  @return NSLayoutConstraint对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">+(<span class="keyword">instancetype</span>)constraintWithItem:(<span class="keyword">id</span>)view1 attribute:(<span class="built_in">NSLayoutAttribute</span>)attr1 relatedBy:(<span class="built_in">NSLayoutRelation</span>)relation toItem:(<span class="keyword">id</span>)view2 attribute:(<span class="built_in">NSLayoutAttribute</span>)attr2 multiplier:(<span class="built_in">CGFloat</span>)multiplier constant:(<span class="built_in">CGFloat</span>)c</span><br><span class="line"><span class="comment">//一部分NSLayoutAttribute的枚举值</span></span><br><span class="line"><span class="built_in">NSLayoutAttributeLeft</span> = <span class="number">1</span>,<span class="comment">//控件左边</span></span><br><span class="line"><span class="built_in">NSLayoutAttributeRight</span>,<span class="comment">//控件右边</span></span><br><span class="line"><span class="built_in">NSLayoutAttributeTop</span>,<span class="comment">//控件上边</span></span><br><span class="line"><span class="built_in">NSLayoutAttributeBottom</span>,<span class="comment">//控件下边</span></span><br><span class="line"><span class="built_in">NSLayoutAttributeLeading</span>,<span class="comment">//控件左边</span></span><br><span class="line"><span class="built_in">NSLayoutAttributeTrailing</span>,<span class="comment">//控件右边</span></span><br><span class="line"><span class="built_in">NSLayoutAttributeWidth</span>,<span class="comment">//控件的宽</span></span><br><span class="line"><span class="built_in">NSLayoutAttributeHeight</span>,<span class="comment">//控件的高</span></span><br><span class="line"><span class="built_in">NSLayoutAttributeCenterX</span>,<span class="comment">//竖直方向的中点</span></span><br><span class="line"><span class="built_in">NSLayoutAttributeCenterY</span>,<span class="comment">//水平方向的中点</span></span><br><span class="line"><span class="comment">//下面看具体的用法</span></span><br><span class="line"><span class="comment">//创建redView</span></span><br><span class="line"><span class="built_in">UIView</span> *redView = [[<span class="built_in">UIView</span> alloc]init];</span><br><span class="line">redView.backgroundColor = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">redView.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</span><br><span class="line">[<span class="keyword">self</span>.view addSubview:redView];    </span><br><span class="line"><span class="comment">//1.创建redView的第一个约束，相对self.view的左边缘间距为20</span></span><br><span class="line"><span class="built_in">NSLayoutConstraint</span> *redLeftC = [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:redView attribute:<span class="built_in">NSLayoutAttributeLeft</span> relatedBy:<span class="built_in">NSLayoutRelationEqual</span> toItem:<span class="keyword">self</span>.view attribute:<span class="built_in">NSLayoutAttributeLeft</span> multiplier:<span class="number">1.0</span>f constant:<span class="number">20.0</span>f];</span><br><span class="line"><span class="comment">//只有在没有参照控件的时候，约束才加到自己身上，否则加到父控件上</span></span><br><span class="line">[<span class="keyword">self</span>.view addConstraint:redLeftC];</span><br><span class="line"><span class="comment">//2.创建redView的第二个约束，相对self.view的底边缘间距为20</span></span><br><span class="line"><span class="built_in">NSLayoutConstraint</span> *redBottomC = [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:redView attribute:<span class="built_in">NSLayoutAttributeBottom</span> relatedBy:<span class="built_in">NSLayoutRelationEqual</span> toItem:<span class="keyword">self</span>.view attribute:<span class="built_in">NSLayoutAttributeBottom</span> multiplier:<span class="number">1.0</span>f constant:<span class="number">-20.0</span>f];</span><br><span class="line">[<span class="keyword">self</span>.view addConstraint:redBottomC];</span><br><span class="line"><span class="comment">//创建redView的第三个约束，设置自身的宽，宽可以参照其它控件进行设置，比如self.view的一半</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[NSLayoutConstraint constraintWithItem:redView attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeWidth multiplier:0.5f constant:0.0f];</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//3.这里直接设置宽为50</span></span><br><span class="line"><span class="built_in">NSLayoutConstraint</span> *redWidthC = [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:redView attribute:<span class="built_in">NSLayoutAttributeWidth</span> relatedBy:<span class="built_in">NSLayoutRelationEqual</span> toItem:<span class="literal">nil</span> attribute:<span class="built_in">NSLayoutAttributeNotAnAttribute</span> multiplier:<span class="number">1.0</span>f constant:<span class="number">50.0</span>f];</span><br><span class="line"><span class="comment">//由于没有参照物，约束加到自己身上</span></span><br><span class="line">[redView addConstraint:redWidthC];</span><br><span class="line"><span class="comment">//4.创建最后一个约束，自身的高</span></span><br><span class="line"><span class="built_in">NSLayoutConstraint</span> *redHeightC = [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:redView attribute:<span class="built_in">NSLayoutAttributeHeight</span> relatedBy:<span class="built_in">NSLayoutRelationEqual</span> toItem:<span class="literal">nil</span> attribute:<span class="built_in">NSLayoutAttributeNotAnAttribute</span> multiplier:<span class="number">1.0</span>f constant:<span class="number">50.0</span>f];</span><br><span class="line"><span class="comment">//由于没有参照物，约束加到自己身上</span></span><br><span class="line">[redView addConstraint:redHeightC];</span><br><span class="line"><span class="comment">//这时候，redView的位置和尺寸都可以确定了，如下图</span></span><br></pre></td></tr></table></figure><p><img src="https://foolpermi-blog-1254115483.cos.ap-chengdu.myqcloud.com/images/cocoa/Autolayout%E6%80%BB%E7%BB%93_01.jpg" width="320" height="568" align="center"></p></li><li><p>现在继续增加需求，我们在红色方块右边离它20间距，离 self.view 底部也20个间距，放置一个宽高相等的蓝色方块</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先创建一个蓝色的视图</span></span><br><span class="line"><span class="built_in">UIView</span> *blueView = [[<span class="built_in">UIView</span> alloc]init];</span><br><span class="line">blueView.backgroundColor = [<span class="built_in">UIColor</span> blueColor];</span><br><span class="line">blueView.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</span><br><span class="line">[<span class="keyword">self</span>.view addSubview:blueView];</span><br><span class="line"><span class="comment">//1.创建第一个约束，左边间距，由于是想要与红色有20的间距，那么参数"toItem"就应该填redView</span></span><br><span class="line"><span class="built_in">NSLayoutConstraint</span> *blueLeft = [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:blueView attribute:<span class="built_in">NSLayoutAttributeLeft</span> relatedBy:<span class="built_in">NSLayoutRelationEqual</span> toItem:redView attribute:<span class="built_in">NSLayoutAttributeRight</span> multiplier:<span class="number">1.0</span>f constant:<span class="number">20.0</span>f];</span><br><span class="line">[<span class="keyword">self</span>.view addConstraint:blueLeft];</span><br><span class="line"><span class="comment">//2.创建第二个约束，底边约束，由于是想与底边有20的间距，比self.view的坐标小，所以为-20</span></span><br><span class="line"><span class="built_in">NSLayoutConstraint</span> *blueBottom = [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:blueView attribute:<span class="built_in">NSLayoutAttributeBottom</span> relatedBy:<span class="built_in">NSLayoutRelationEqual</span> toItem:<span class="keyword">self</span>.view attribute:<span class="built_in">NSLayoutAttributeBottom</span> multiplier:<span class="number">1.0</span>f constant:<span class="number">-20.0</span>f];</span><br><span class="line">[<span class="keyword">self</span>.view addConstraint:blueBottom];</span><br><span class="line"><span class="comment">//3.创建第三个约束，确定蓝色视图的宽</span></span><br><span class="line"><span class="built_in">NSLayoutConstraint</span> *blueWidth = [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:blueView attribute:<span class="built_in">NSLayoutAttributeWidth</span> relatedBy:<span class="built_in">NSLayoutRelationEqual</span> toItem:redView attribute:<span class="built_in">NSLayoutAttributeWidth</span> multiplier:<span class="number">1.0</span>f constant:<span class="number">0.0</span>f];</span><br><span class="line">[<span class="keyword">self</span>.view addConstraint:blueWidth];</span><br><span class="line"><span class="comment">//4.创建第四个约束，确定蓝色视图的高</span></span><br><span class="line"><span class="built_in">NSLayoutConstraint</span> *blueHeight = [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:blueView attribute:<span class="built_in">NSLayoutAttributeHeight</span> relatedBy:<span class="built_in">NSLayoutRelationEqual</span> toItem:redView attribute:<span class="built_in">NSLayoutAttributeHeight</span> multiplier:<span class="number">1.0</span>f constant:<span class="number">0.0</span>f];</span><br><span class="line">[<span class="keyword">self</span>.view addConstraint:blueHeight];</span><br></pre></td></tr></table></figure><p><img src="https://foolpermi-blog-1254115483.cos.ap-chengdu.myqcloud.com/images/cocoa/Autolayout%E6%80%BB%E7%BB%93_02.jpg" width="320" height="568" align="center"></p></li><li><p>其实 Autolayout 的思想还是比较简单，刚开始使用的时候不要想着一气呵成，可以一个控件一个控件的实现依赖，分别满足其位置和尺寸的需求，如果几个控件一起弄得话，需要思路非常清晰，往往大家犯错是因为约束加多了，而不是加少了</p></li><li><p>就如上面的例子，很多人在设置了与红色等高等宽以后，还同时设置顶部和底部对齐，这样高度就重复设置了。因为上下同时对齐不仅给予了垂直位置，也给予了高度，所以思路必须清晰。</p></li></ul><h2 id="Autolayout动画"><a href="#Autolayout动画" class="headerlink" title="Autolayout动画"></a>Autolayout动画</h2><ul><li><p>最后在原来的例子上做个小动画，让大家了解 Autolayout 是怎么做动画的</p></li><li><p>需求：将在蓝色方块的右边再加个同样大小的黄色方块，然后要求点击屏幕，蓝色的方块被移除，黄色方块取代蓝色方块的位置</p></li><li><p>这个例子主要涉及到 Autolayout 的另一个知识点：<strong>优先级(priority)</strong></p></li><li><p>好了，下面添加黄色的方块</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先添加黄色View</span></span><br><span class="line"><span class="built_in">UIView</span> *yellowView = [[<span class="built_in">UIView</span> alloc]init];</span><br><span class="line">yellowView.backgroundColor = [<span class="built_in">UIColor</span> yellowColor];</span><br><span class="line">yellowView.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</span><br><span class="line">[<span class="keyword">self</span>.view addSubview:yellowView];</span><br><span class="line"><span class="comment">//1.创建第一个约束，左边间距</span></span><br><span class="line"><span class="built_in">NSLayoutConstraint</span> *yellowLeft = [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:yellowView attribute:<span class="built_in">NSLayoutAttributeLeft</span> relatedBy:<span class="built_in">NSLayoutRelationEqual</span> toItem:blueView attribute:<span class="built_in">NSLayoutAttributeRight</span> multiplier:<span class="number">1.0</span>f constant:<span class="number">20.0</span>f];</span><br><span class="line">[<span class="keyword">self</span>.view addConstraint:yellowLeft];</span><br><span class="line"><span class="comment">//2.创建第二个约束，底部间距</span></span><br><span class="line"><span class="built_in">NSLayoutConstraint</span> *yellowBottom = [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:yellowView attribute:<span class="built_in">NSLayoutAttributeBottom</span> relatedBy:<span class="built_in">NSLayoutRelationEqual</span> toItem:<span class="keyword">self</span>.view attribute:<span class="built_in">NSLayoutAttributeBottom</span> multiplier:<span class="number">1.0</span>f constant:<span class="number">-20.0</span>f];</span><br><span class="line">[<span class="keyword">self</span>.view addConstraint:yellowBottom];</span><br><span class="line"><span class="comment">//3.创建第三个约束，宽度</span></span><br><span class="line"><span class="built_in">NSLayoutConstraint</span> *yellowWidth = [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:yellowView attribute:<span class="built_in">NSLayoutAttributeWidth</span> relatedBy:<span class="built_in">NSLayoutRelationEqual</span> toItem:<span class="literal">nil</span> attribute:<span class="built_in">NSLayoutAttributeNotAnAttribute</span> multiplier:<span class="number">1.0</span>f constant:<span class="number">50.0</span>f];</span><br><span class="line">[yellowView addConstraint:yellowWidth];</span><br><span class="line"><span class="comment">//4.创建第四个约束，高度</span></span><br><span class="line"><span class="built_in">NSLayoutConstraint</span> *yellowHeight = [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:yellowView attribute:<span class="built_in">NSLayoutAttributeHeight</span> relatedBy:<span class="built_in">NSLayoutRelationEqual</span> toItem:<span class="literal">nil</span> attribute:<span class="built_in">NSLayoutAttributeNotAnAttribute</span> multiplier:<span class="number">1.0</span>f constant:<span class="number">50.0</span>f];</span><br><span class="line">[yellowView addConstraint:yellowHeight];</span><br></pre></td></tr></table></figure><p><img src="https://foolpermi-blog-1254115483.cos.ap-chengdu.myqcloud.com/images/cocoa/Autolayout%E6%80%BB%E7%BB%93_03.jpg" width="320" height="568" align="center"></p></li><li><p>接下来给黄色添加一个约束，这个约束涉及到优先级，代码如下</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.yellowView创建另一个左边约束</span></span><br><span class="line"><span class="built_in">NSLayoutConstraint</span> *yellowAnotherLeft = [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:yellowView attribute:<span class="built_in">NSLayoutAttributeLeft</span> relatedBy:<span class="built_in">NSLayoutRelationEqual</span> toItem:redView attribute:<span class="built_in">NSLayoutAttributeRight</span> multiplier:<span class="number">1.0</span>f constant:<span class="number">20.</span>f];</span><br><span class="line"><span class="comment">//2.设置优先级</span></span><br><span class="line"><span class="built_in">UILayoutPriority</span> priority = <span class="number">250</span>;</span><br><span class="line">yellowAnotherLeft.priority = priority;</span><br><span class="line"><span class="comment">//3.约束添加到父视图上</span></span><br><span class="line">[<span class="keyword">self</span>.view addConstraint:yellowAnotherLeft];</span><br></pre></td></tr></table></figure></li><li><p>约束的优先级的范围是0~1000，数值越大优先级越高，在不设置的情况下默认值是1000</p></li><li><p>这说明，最后添加的约束的优先级是低的，这个约束只有在它的冲突约束被抹掉以后，它才能实现，也就是说，当把蓝色 view 移除以后，黄色 view相对于蓝色 view 左间距20这个约束就不成立了，那么黄色 view 会自动地变为与红色 view 的间距为20</p><p><img src="https://foolpermi-blog-1254115483.cos.ap-chengdu.myqcloud.com/images/cocoa/Autolayout%E6%80%BB%E7%BB%93_04.jpg" width="320" height="568" align="center"></p></li></ul><ul><li><p>最后加几行代码来实现这个动画吧</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line"><span class="comment">//1.先把蓝色从父视图上移除</span></span><br><span class="line">    [<span class="keyword">self</span>.blueView removeFromSuperview];</span><br><span class="line">    <span class="comment">//2.重新布局页面</span></span><br><span class="line">    [<span class="built_in">UIView</span> animateWithDuration:<span class="number">1.0</span> animations:^&#123;</span><br><span class="line">        [<span class="keyword">self</span>.view layoutIfNeeded];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="VFL实现Autolayout"><a href="#VFL实现Autolayout" class="headerlink" title="VFL实现Autolayout"></a>VFL实现Autolayout</h2><ul><li><p>之前介绍了使用苹果原始 API 实现 Autolayout，现在介绍使用 VFL (Visual Format Language) 来实现 Autolayout</p></li><li><p>VFL 的思想与其它的实现方式有所不同，它更为宏观化，它将约束分成了两块：<strong>水平方向 (H:) </strong>和<strong>垂直方向 (V:)</strong></p></li><li><p>也就是说在创建约束的时候，得把水平方向和垂直方向用字符串一并表示出来而不是一个一个的添加</p></li><li><p>下面看 VFL 的 API，它的 API 短了一些，但是要筹齐参数是件很麻烦的事情</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  VFL创建约束的API</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*  @param format  传入某种格式构成的字符串，用以表达想要添加的约束，如@"H:|-margin-[redView(50)]"，水平方向上，redView与父控件左边缘保持“margin”间距，redView的宽为50</span></span><br><span class="line"><span class="comment">*  @param opts    对齐方式，是个枚举值</span></span><br><span class="line"><span class="comment">*  @param metrics 一般传入以间距为KEY的字典，如： @&#123; @"margin":@20&#125;，KEY要与format参数里所填写的“margin”相同</span></span><br><span class="line"><span class="comment">*  @param views   传入约束中提到的View，也是要传入字典，但是KEY一定要和format参数里所填写的View名字相同，如：上面填的是redView，所以KEY是@“redView”</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*  @return 返回约束的数组</span></span><br><span class="line"><span class="comment">*/</span>(<span class="built_in">NSArray</span> *)constraintsWithVisualFormat:(<span class="built_in">NSString</span> *)format options:(<span class="built_in">NSLayoutFormatOptions</span>)opts metrics:(<span class="built_in">NSDictionary</span> *)metrics views:(<span class="built_in">NSDictionary</span> *)views;</span><br><span class="line"><span class="comment">//部分NSLayoutFormatOptions的枚举选项</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">NSLayoutFormatAlignAllLeft = (1 &lt;&lt; NSLayoutAttributeLeft),//左边缘对齐</span></span><br><span class="line"><span class="comment">NSLayoutFormatAlignAllRight = (1 &lt;&lt; NSLayoutAttributeRight),//右边缘对齐    </span></span><br><span class="line"><span class="comment">NSLayoutFormatAlignAllTop = (1 &lt;&lt; NSLayoutAttributeTop),//上边缘对齐</span></span><br><span class="line"><span class="comment">NSLayoutFormatAlignAllBottom = (1 &lt;&lt; NSLayoutAttributeBottom),//下边缘对齐</span></span><br><span class="line"><span class="comment">NSLayoutFormatAlignAllLeading = (1 &lt;&lt; NSLayoutAttributeLeading),//左边缘对齐</span></span><br><span class="line"><span class="comment">NSLayoutFormatAlignAllTrailing = (1 &lt;&lt; NSLayoutAttributeTrailing),//右边缘对齐</span></span><br><span class="line"><span class="comment">NSLayoutFormatAlignAllCenterX = (1 &lt;&lt; NSLayoutAttributeCenterX),//垂直方向中心对齐</span></span><br><span class="line"><span class="comment">NSLayoutFormatAlignAllCenterY = (1 &lt;&lt; NSLayoutAttributeCenterY),//水平方向中心对齐</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>里面最重要的就是 <strong>format</strong> 参数，这个参数的难点在于其书写格式</p></li><li><p>通过例子来看 API 的使用，现在要在界面上添加一个红色的方块，高100，宽50，与父视图顶部边缘和左边缘距离为20</p></li><li><p>来看看代码是怎么实现的</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIView</span> *redView = [[<span class="built_in">UIView</span> alloc]init];</span><br><span class="line">redView.backgroundColor = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">redView.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</span><br><span class="line">[<span class="keyword">self</span>.view addSubview:redView];</span><br><span class="line"><span class="comment">//接下来开始写API所需要的参数了</span></span><br><span class="line"><span class="comment">//format参数</span></span><br><span class="line"><span class="comment">//Hvfl与Vvfl分别是水平方向与垂直方向的约束，等下之后会有解析</span></span><br><span class="line"><span class="built_in">NSString</span> *Hvfl = <span class="string">@"H:|-margin-[redView(50)]"</span>;</span><br><span class="line"><span class="built_in">NSString</span> *Vvfl = <span class="string">@"V:|-margin-[redView(100)]"</span>;</span><br><span class="line"><span class="comment">//设置margin的数值</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *metrics = @&#123; <span class="string">@"margin"</span>:@<span class="number">20</span>&#125;;</span><br><span class="line"><span class="comment">//把要添加约束的View转成字典</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *views = <span class="built_in">NSDictionaryOfVariableBindings</span>(redView);<span class="comment">//这个方法会自动把传入的参数以字典的形式返回，字典的KEY就是其本身的名字</span></span><br><span class="line"><span class="comment">//如@&#123;@"redView"：redView&#125;</span></span><br><span class="line"><span class="comment">//添加对齐方式，</span></span><br><span class="line"><span class="built_in">NSLayoutFormatOptions</span> ops = <span class="built_in">NSLayoutFormatAlignAllLeft</span> | <span class="built_in">NSLayoutFormatAlignAllTop</span>;<span class="comment">//左边与顶部</span></span><br><span class="line"><span class="comment">//参数已经设置完了，接收返回的数组，用以self.view添加</span></span><br><span class="line"><span class="built_in">NSArray</span> *Hconstraints = [<span class="built_in">NSLayoutConstraint</span> constraintsWithVisualFormat:Hvfl options:ops metrics:metrics views:views];</span><br><span class="line"><span class="built_in">NSArray</span> *Vconstraints = [<span class="built_in">NSLayoutConstraint</span> constraintsWithVisualFormat:Vvfl options:ops metrics:metrics views:views];</span><br><span class="line"><span class="comment">//self.view分别添加水平与垂直方向的约束</span></span><br><span class="line">[<span class="keyword">self</span>.view addConstraints:Hconstraints];</span><br><span class="line">[<span class="keyword">self</span>.view addConstraints:Vconstraints];</span><br><span class="line"><span class="comment">//运行结果如下图</span></span><br></pre></td></tr></table></figure><p><img src="https://foolpermi-blog-1254115483.cos.ap-chengdu.myqcloud.com/images/cocoa/Autolayout%E6%80%BB%E7%BB%93_05.jpg" width="320" height="568" align="center"></p></li><li><p>如图，需求已经实现了，下面解释一下<strong>format</strong>里面奇怪的语法</p><ul><li>每个前面都要加 <strong>@”H:”</strong> 或者 <strong>@”V:”</strong>，分别表示水平和垂直方向</li><li><strong>@”|”</strong>代表着边界，很形象</li><li><strong>@”-“</strong>用来表示间隙，一般以这样的形式出现<strong>@”-20-“</strong>，这代表20的间距，也可以填写表示，如 <strong>@”-margin-“</strong>，之后设置替换参数 <strong>metrics**</strong></li><li><strong>@”[]”</strong>中括号里放的是要添加约束的 View，如上边例子的 <strong>redView</strong>，要想设置宽度和高度就这样 <strong>[redView(50)]</strong>，水平方向上 <strong>(H:)</strong> 表示的数字是宽，垂直方向上 <strong>(V:)</strong> 表示的数字是高</li></ul></li><li><p>基本的用法就是这样，更多的东西要在代码中体会，现在做一个稍微复杂的例子，这个例子和以前使用苹果原始 API实现的例子一样，就是在距离 self.view 的底部20间距的地方放置3个方块，红、蓝、黄分别间距20，宽高相同，都为50</p></li><li><p>接下来看代码</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//translatesAutoresizingMaskIntoConstraints属性设置为NO，防止苹果把默认设置的Autoresizing属性转成Autolayout，造成错误</span></span><br><span class="line"><span class="comment">//依次创建三个View</span></span><br><span class="line"><span class="built_in">UIView</span> *redView = [[<span class="built_in">UIView</span> alloc]init];</span><br><span class="line">    redView.backgroundColor = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    redView.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:redView];</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">UIView</span> *blueView = [[<span class="built_in">UIView</span> alloc]init];</span><br><span class="line">    blueView.backgroundColor = [<span class="built_in">UIColor</span> blueColor];</span><br><span class="line">    blueView.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:blueView];</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">UIView</span> *yellowView = [[<span class="built_in">UIView</span> alloc]init];</span><br><span class="line">    yellowView.backgroundColor = [<span class="built_in">UIColor</span> yellowColor];</span><br><span class="line">    yellowView.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:yellowView];</span><br><span class="line"><span class="comment">//view添加完了，开始创建约束</span></span><br><span class="line"><span class="comment">//1.创建水平方向约束</span></span><br><span class="line"><span class="built_in">NSString</span> *Hvfl = <span class="string">@"H:|-margin-[redView(50)]-margin-[blueView(==redView)]-margin-[yellowView(==redView)]"</span>;</span><br><span class="line"><span class="comment">//大家认真体会一下上面这个字符串</span></span><br><span class="line"><span class="comment">//如果翻译过来就是，边缘-间距-红色view（宽50）-间距-蓝色View（宽等于红色View的宽）-间距-黄色View（宽等于红色View的宽）</span></span><br><span class="line"><span class="comment">//设置间距要替换的数值，用字典形式</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *metrics = @&#123; <span class="string">@"margin"</span>:@<span class="number">20</span>&#125;;</span><br><span class="line"><span class="comment">//把要添加约束的View都转成字典形式</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *views = <span class="built_in">NSDictionaryOfVariableBindings</span>(redView,blueView,yellowView);</span><br><span class="line"><span class="comment">//设置对齐方式，顶部与底部都与红色View对齐</span></span><br><span class="line"><span class="built_in">NSLayoutFormatOptions</span> ops = <span class="built_in">NSLayoutFormatAlignAllTop</span>|<span class="built_in">NSLayoutFormatAlignAllBottom</span>;</span><br><span class="line"><span class="comment">//创建水平方向约束</span></span><br><span class="line"><span class="built_in">NSArray</span> *Hconstraints = [<span class="built_in">NSLayoutConstraint</span> constraintsWithVisualFormat:Hvfl options:ops metrics:metrics views:views];</span><br><span class="line"><span class="comment">//这里依然要设置红色view的高，因为水平方向的约束没有设置红色View的高，其他View仅仅是与它顶部底部对齐，但是高依然未知</span></span><br><span class="line"><span class="built_in">NSString</span> *Vvfl = <span class="string">@"V:[redView(50)]-margin-|"</span>;</span><br><span class="line"><span class="comment">//创建垂直方向约束</span></span><br><span class="line"><span class="built_in">NSArray</span> *Vconstraints = [<span class="built_in">NSLayoutConstraint</span> constraintsWithVisualFormat:Vvfl options:ops metrics:metrics views:views];</span><br><span class="line"><span class="comment">//父控件添加约束</span></span><br><span class="line">[<span class="keyword">self</span>.view addConstraints:Hconstraints];</span><br><span class="line">[<span class="keyword">self</span>.view addConstraints:Vconstraints];</span><br><span class="line"><span class="comment">//最终效果图如下:</span></span><br></pre></td></tr></table></figure><p><img src="https://foolpermi-blog-1254115483.cos.ap-chengdu.myqcloud.com/images/cocoa/Autolayout%E6%80%BB%E7%BB%93_06.jpg" width="320" height="568" align="center"></p></li></ul><h2 id="Masonry实现Autolayout"><a href="#Masonry实现Autolayout" class="headerlink" title="Masonry实现Autolayout"></a>Masonry实现Autolayout</h2><p>Masonry 是 iOS 和 OS X 平台上非常优秀的第三方 Autolayout 框架，采用更优雅的链式语法对原生 API 进行封装，简洁明了并具有很高的可读性。</p><p>先看一段 sample code 来认识 Masonry:</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIEdgeInsets</span> padding = <span class="built_in">UIEdgeInsetsMake</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">[view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">make.edges.equalTo(superview).with.insets(padding);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>看看 block 里面的那句话:<em>make edges equalTo superview with insets</em>,通过类似于自然语言的几行代码就把 view1 约束好了，通俗易懂。</p><p>先看看 Masonry 支持哪些属性</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *left; <span class="comment">//左侧</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *right; <span class="comment">//右侧</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *top; <span class="comment">//上侧</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *bottom; <span class="comment">//下侧</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *leading; <span class="comment">//首部</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *trailing; <span class="comment">//尾部</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *width; <span class="comment">//宽</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *height; <span class="comment">//高</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *centerX; <span class="comment">//横向中点</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *centerY; <span class="comment">//纵向中点</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *baseline; <span class="comment">//文本基线</span></span><br></pre></td></tr></table></figure><p>其中 leading 与 left、trailing 与 right 在正常情况下是等价的，除了一些特殊情况下，比如阿拉伯文，正常使用情况下基本上可以不理不用，用 left 和 right 就好了。下面通过一些简单的实例来学习如何愉快的使用 Masonry:</p><p><strong>1.居中显示一个 view</strong></p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad&#123;</span><br><span class="line">  [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">  <span class="built_in">UIView</span> *sv = [[<span class="built_in">UIView</span> alloc]init];</span><br><span class="line">  sv.backgroundColor = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">  [<span class="keyword">self</span>.view addSubview:sv];</span><br><span class="line">  [sv mas_makeConstraints:^(MASConstraintMaker *make)&#123;</span><br><span class="line">    make.center.equalTo(<span class="keyword">self</span>.view);</span><br><span class="line">    make.size.mas_equalTo(<span class="built_in">CGSizeMake</span>(<span class="number">300</span>,<span class="number">300</span>));</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：</p><p>1.<a href="http://www.jianshu.com/p/d7a4790090f1" target="_blank" rel="noopener">iOS Autolayout之Apple原生代码实现</a> </p><p>2.<a href="http://www.jianshu.com/p/757cc57fd9ea" target="_blank" rel="noopener">iOS Autolayout之VFL</a> </p><p>3.<a href="http://adad184.com/2014/09/28/use-masonry-to-quick-solve-autolayout/" target="_blank" rel="noopener">Masonry介绍与使用</a></p>]]></content>
      
      <categories>
          
          <category> Cocoa </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cocoa </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Objective-C的虚方法</title>
      <link href="/cactus-dark/2015/12/28/Objective-C%E7%9A%84%E8%99%9A%E6%96%B9%E6%B3%95/"/>
      <url>/cactus-dark/2015/12/28/Objective-C%E7%9A%84%E8%99%9A%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>OC 的方法都是虚方法:<br>1.父类的指针可以指向子类的对象<br>2.调用方法时不看指针看对象    </p><a id="more"></a><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类，有一个方法jump</span></span><br><span class="line"><span class="comment">//Father.h</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Father</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="keyword">void</span>)jump;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Father.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Father.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Father</span></span></span><br><span class="line">-(<span class="keyword">void</span>)jump</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"Father can jump 1.2m."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//子类，重写了jump方法</span></span><br><span class="line"><span class="comment">//Son.h</span></span><br><span class="line"><span class="meta">#import<span class="meta-string">"Father.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Son</span> : <span class="title">Father</span></span></span><br><span class="line"><span class="comment">//重写，无需声明</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Son.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Son.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Son</span></span></span><br><span class="line">-(<span class="keyword">void</span>)jump</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"Son can jump 1.8m."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//main.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Father.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Son.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc,<span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">@autoreleasepool</span>&#123;</span><br><span class="line">    Son* son = [[Son alloc]init];</span><br><span class="line">    Father* father = son;<span class="comment">//父类的指针指向子类的对象</span></span><br><span class="line">    [father jump];<span class="comment">//调用父类的jump还是子类的jump?</span></span><br><span class="line">    <span class="comment">//调用的仍然是子类的方法</span></span><br><span class="line">    <span class="comment">//调用方法时不看指针，看对象</span></span><br><span class="line">    <span class="comment">//对象的地址调用对象的方法</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的方法叫做虚方法，可以描述不同事物被相同事件触发，产生不同的响应（结果）。下面写一个殴打小动物的程序。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类，Animal，有一个beBeaten方法，描述被打时的响应</span></span><br><span class="line"><span class="comment">//Animal.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Animal</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)beBeaten;<span class="comment">//被打时的响应</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Animal.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Animal.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Animal</span></span></span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)beBeaten</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> ;<span class="comment">//虚方法，可以什么都不做，每个子类都会重写这个方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Cat.h</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Animal.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Cat</span> : <span class="title">Animal</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Cat.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Cat.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Cat</span></span></span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)beBeaten</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"Bark and jump to high!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Dog.h</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Animal.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Dog</span> : <span class="title">Animal</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Dog.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Dog.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Dog</span></span></span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)beBeaten</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"Give a hard bit!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Frog.h</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Animal.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Frog</span> : <span class="title">Animal</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Frog.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Frog.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Frog</span></span></span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)beBeaten</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"Do nothing!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Human类，有一个方法beat</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Fountion.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Animal.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Human</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)beatAnimal:(Animal*)animal;<span class="comment">//父类的指针可以指向任意一个子类的地址，否则，殴打不同的动物，就需要创建不同的动物对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Human.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Human.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Human</span></span></span><br><span class="line"><span class="comment">//只需要写一个方法，尽管动物不同，这就是父类可以指向子类的好处</span></span><br><span class="line">-(<span class="keyword">void</span>)beatAnimal:(Animal*)animal</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"Human beat the %@"</span>,[animal <span class="keyword">class</span>]);</span><br><span class="line">  [animal beBeaten];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//main.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Dog.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Cat.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Frog.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Human.h"</span></span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc,<span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">@autoreleasepool</span>&#123;</span><br><span class="line">    Frog* frog = [[Frog alloc]init];</span><br><span class="line">    Dog* dog = [[Dog alloc]init];</span><br><span class="line">    Cat* cat = [[Cat alloc]init];</span><br><span class="line">    Human* Linda = [[Human alloc]init]; <span class="comment">//who is Linda?</span></span><br><span class="line">    [Linda beatAnimal:frog]; <span class="comment">//不同的事物被相同的事件触发，产生不同的响应</span></span><br><span class="line">    [Linda beatAnimal:cat];</span><br><span class="line">    [Linda beatAnimal:dog];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Objective-C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> objc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Objective-C的内存管理</title>
      <link href="/cactus-dark/2015/12/26/Objective-C%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/cactus-dark/2015/12/26/Objective-C%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<p>首先谢谢 <a href="http://blog.csdn.net/lonelyroamer/article/details/7666851" target="_blank" rel="noopener">LonelyRoamer</a>   ，它的文章让我明白一些事情。整理如下，分享给大家： </p><h2 id="一、内存管理的黄金法则"><a href="#一、内存管理的黄金法则" class="headerlink" title="一、内存管理的黄金法则:"></a>一、内存管理的黄金法则:</h2><p>如果一个对象使用了  alloc、copy、mutableCopy、retain、new，那你就必须使用相应的 release 或 autorelease.<br><a id="more"></a></p><h2 id="二、内存管理类型分类"><a href="#二、内存管理类型分类" class="headerlink" title="二、内存管理类型分类"></a>二、内存管理类型分类</h2><p>基本类型和 C 语言类型：如 int、short、char、struct、enum、union等类型.<br>Objective-C 类型：任何继承于 NSObject 的对象都属于 Objective-C 的类型。<br>我们讲的内存管理实际上是对 Objective-C 类型的内存管理，它对基本数据类型和 C 语言的类型并不管用。 </p><h2 id="三、C-和-C-内存管理的不足"><a href="#三、C-和-C-内存管理的不足" class="headerlink" title="三、C 和 C++ 内存管理的不足"></a>三、C 和 C++ 内存管理的不足</h2><p>当有多个指针同时指向同一块内存的时候，任何一个调用了 free 方法释放了内存，而其余指针在不知情的情况下继续使用这块内存就会出现问题，何时由谁去释放这块内存，就是 C 和 C++ 在内存管理上的混乱。 </p><h2 id="四、Objective-C-对象在内存中的结构"><a href="#四、Objective-C-对象在内存中的结构" class="headerlink" title="四、Objective-C 对象在内存中的结构"></a>四、Objective-C 对象在内存中的结构</h2><p>所有的 Objective-C 类型对象的结构如下，这个对象的内存在包含自己的变量和方法的基础上还包含一个名为 retainCount 的引用计数器用来表示当前对象被引用的次数，如果引用次数为0，就会调 dealloc 释放这块内存。</p><p><strong>MRC规则：</strong></p><ul><li>Objective-C 类中实现了引用计数器，对象知道自己当前被引用的次数</li><li>一个对象被初始 alloc 以后 retainCount  为1</li><li>如果需要引用对象，可以给对象发送一个 retain 消息，这样对象的 retainCount 就加1</li><li>当不需要引用对象了，可以给对象发送 release 消息，这样对象 retainCount 就减1</li><li>当 retainCount 减到0，自动调用对象的 dealloc 函数，对象就会释放内存</li><li>计数器为0的对象不能再使用 release 和其他方法</li></ul><h2 id="五、举例说明"><a href="#五、举例说明" class="headerlink" title="五、举例说明"></a>五、举例说明</h2><p>比如有一个引擎类 Engine, 有一个类 Car, Car 里面有一个 Engine 的实例变量，一个 setter 和一个 getter 方法，如下所示：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Car.h"</span>  </span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Car</span></span></span><br><span class="line">- (<span class="keyword">void</span>) setEngine: (Engine*) engine &#123;</span><br><span class="line">  _engine = engine;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Engine*) engine &#123;</span><br><span class="line">  <span class="keyword">return</span> _engine; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) dealloc &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"Car is dealloc"</span>);</span><br><span class="line">  [<span class="keyword">super</span> dealloc];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>上面写的是一个简单的类，但是这样写是有问题，需要一步步的改进。<br><strong>第一步改进：</strong><br>先使用它看问题的所在，在 main 方法里面如下使用：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先创建一个引擎</span></span><br><span class="line">Engine* engine1 = [[Engine alloc]init];</span><br><span class="line">[engine setID: <span class="number">1</span>]；</span><br><span class="line"><span class="comment">//再创建一个汽车，设置汽车的引擎</span></span><br><span class="line">Car* car = [[Car alloc]init];<span class="comment">//retainCount=1</span></span><br><span class="line">[car setEngine: engine];</span><br><span class="line"><span class="comment">/*分析：在这里，现在有两个引用指向这个Engine对象，engine1和Car中的_engine，可是这个Engine对象的引用计数还为1，因为在setter方法中，并没有使用retain。那么不管是那个引用调用release，那么另外一个引用都将指向一块释放掉的内存，那么肯定会发生错误，所以需要在setter方法中改进。*/</span></span><br></pre></td></tr></table></figure></p><p><strong>第二步改进：</strong><br>setter 方法改进<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) setEngine: (Engine*) engine &#123;</span><br><span class="line">  _engine = [engine <span class="keyword">retain</span>];<span class="comment">//多一个引用，retainCount+1 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再在 main 中使用它:<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先创建一个引擎</span></span><br><span class="line">Engine* engine1 = [[Engine alloc]init];</span><br><span class="line">[engine1 setID: <span class="number">1</span>];</span><br><span class="line"><span class="comment">//再创建一个汽车，设置汽车的引擎</span></span><br><span class="line">Car* car = [[Car alloc]init];<span class="comment">//retainCount=1</span></span><br><span class="line">[car setEngine: engine1];<span class="comment">//retainCount=2，因为setter中使用了retain</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//假设还有一个引擎</span></span><br><span class="line">Engine* engine2 = [[Engine alloc]init];</span><br><span class="line">[engine2 setID: <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个汽车要换引擎，自然又要调用setter方法</span></span><br><span class="line">[car setEngine: engine2];</span><br><span class="line"><span class="comment">/*分析：这里换了一个引擎，那么它的engine就不再指向engine1的那个对象的内存了，而是换成了engine2，也就是说engine1的那块对象指向的内存的引用只有一个。可是它的retainCount是两个，这就是问题所在，所以仍需要改进*/</span></span><br></pre></td></tr></table></figure></p><p><strong>第三步改进：</strong><br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) setEngine: (Engine*) engine &#123;</span><br><span class="line">  [_engine release];<span class="comment">//在设置之前，先release，那么在设置的时候，就会自动将前面的一个引用release掉</span></span><br><span class="line">  _engine = [engine <span class="keyword">retain</span>];<span class="comment">//多一个引用，retainCount+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再在 main 中使用<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先创建一个引擎</span></span><br><span class="line">Engine* engine1 = [[Engine alloc]init];</span><br><span class="line">[engine1 setID: <span class="number">1</span>];</span><br><span class="line"><span class="comment">//再创建一个汽车，设置汽车的引擎</span></span><br><span class="line">Car* car = [[Car alloc]init];<span class="comment">//retainCount=1</span></span><br><span class="line">[car setEngine: engine1];<span class="comment">//retainCounr=2,因为使用了retain，所以retainCount=2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果进行了一个误操作，又设置了一次engine1</span></span><br><span class="line">[car setEngine: engine1];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*分析：那么，又要重新调用一次setter方法，这根本就是无意义的操作，所以要在设置之间加上判断*/</span></span><br></pre></td></tr></table></figure></p><p><strong>第四步改进：</strong><br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) setEngine: (Engine*) engine &#123;</span><br><span class="line">  <span class="keyword">if</span>（_engine != engine）&#123;<span class="comment">//判断是否重复设置</span></span><br><span class="line">    [_engine release];<span class="comment">//在设置之前，先release，那么在设置的时候就会自动将前面一个引用release掉</span></span><br><span class="line">    _engine = [engine <span class="keyword">retain</span>];<span class="comment">//多了一个引用，retainCount+1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>第五步改进：</strong><br>现在 setter 方法基本没有问题了，那么当我们释放掉一个 car 对象的时候，也要释放它里面 _engine 的引用，所以要重写 Car 的 dealloc 方法。<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) dealloc &#123;</span><br><span class="line">  [_engine release];<span class="comment">//在释放car的时候，释放掉它对engine的引用</span></span><br><span class="line">  [<span class="keyword">super</span> dealloc]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这还不是最好的方法，下面的方法更好<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) dealloc &#123;</span><br><span class="line">  [<span class="keyword">self</span> setEngine: <span class="literal">nil</span>];<span class="comment">//释放car得分时候，使用setEngine设为nil，它不仅会release掉，而且指向nil，即使误操作也不会出错'</span></span><br><span class="line">  [<span class="keyword">super</span> dealloc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以，综上所述，在 setter 方法中的最终写法是<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) setEngine: (Engine*) engine &#123;</span><br><span class="line">  <span class="keyword">if</span>(_engine != engine)&#123;<span class="comment">//判断是否重复</span></span><br><span class="line">    [_engine release];<span class="comment">//设置之前，先release，在设置的时候，就会自动将前面的引用release掉</span></span><br><span class="line">    _engine = [engine <span class="keyword">retain</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也可以是：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) setEngine: (Engine*) engine &#123;</span><br><span class="line">  [engine <span class="keyword">retain</span>]; <span class="comment">//一定注意retain和release的先后顺序，不然engine和_engine相同时会出错</span></span><br><span class="line">  [_engine release];</span><br><span class="line">  _engine = engine;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后在 dealloc 方法中的写法是：</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) dealloc &#123;</span><br><span class="line">  [<span class="keyword">self</span> setEngine:<span class="literal">nil</span>];</span><br><span class="line">  [<span class="keyword">super</span> dealloc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、property中setter的关键字"><a href="#六、property中setter的关键字" class="headerlink" title="六、property中setter的关键字"></a>六、property中setter的关键字</h2><p>在 property 中有三个关键字定义关于展开 setter 方法中的语法，assign、retain、copy.</p><ul><li>assign 展开 setter 的写法</li></ul><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) setEngine: (Engine*) engine &#123;</span><br><span class="line">  _engine = engine;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>retain 展开 setter 的写法</li></ul><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) setEngine: (Engine*) engine &#123;</span><br><span class="line">  <span class="keyword">if</span>(_engine != engine) &#123;<span class="comment">//判读断是否重复设置</span></span><br><span class="line">    [_engine release];<span class="comment">//设置之前，先release，那么在设置的时候就会自动将前面一个引用release掉</span></span><br><span class="line">    _engine = [engine <span class="keyword">retain</span>];<span class="comment">//多了一个引用，retainCount+1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>copy 展开 setter 的写法</li></ul><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) setEngine : (Engine*) engine &#123;</span><br><span class="line">  <span class="keyword">if</span>(_engine!=engine) &#123;<span class="comment">//判断是否重复设置</span></span><br><span class="line">    [_engine release];<span class="comment">//设置之前先release</span></span><br><span class="line">    _engine = [engine <span class="keyword">copy</span>];<span class="comment">//多了一个引用，retainCount+1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 copy 属性有一点要注意，被定义有 copy 属性的对象必须要符合 NSCopying 协议，并且实现 copyWithZone: 方法。可以看到,使用 retain 和我们上面举的例子完全相同，所以我们可以使用 property 和它的 retain 代替之前的写法。</p><h2 id="七、autorelease用法简介"><a href="#七、autorelease用法简介" class="headerlink" title="七、autorelease用法简介"></a>七、autorelease用法简介</h2><p>autorelease 从字面上的意思也很好理解，自动释放池。autorelease 实际上也是将对象进行 release, 但是它将对release 的调用进行了延迟处理，当你使用 autorelease 的时候，并不会立刻将对象的引用计数减1，而是将这个对象放入了 autorelease pool 中，当 pool 被释放时，pool 中的所有对象才会被 release。在每个iOS应用中，大家会看到一个 autorelease pool，在开始时创建，程序结束时释放，那岂不是对象在程序结束时才被 release，跟内存泄漏有什么区别？其实不然。<br>对于每一个 Runloop，系统会隐式创建一些 autorelease pool，这些 pool 会构成一个像 CallStack 一样的栈结构，每一个 runloop 结束的时候，栈顶的 pool 会被销毁，pool 中的对象被自动 release，如果你使用ARC，那么你将不能直接使用 autorelease pool，而是使用 @autoreleasepool block。<br>参考：<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSAutoreleasePool_Class/index.html#//apple_ref/doc/uid/20000051-SW5" target="_blank" rel="noopener">Apple Reference</a> &amp;  <a href="http://www.jianshu.com/p/549c37f60bf7" target="_blank" rel="noopener">What is RunLoop</a><br>例如:<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSAutoreleasePool</span>* pool = [[<span class="built_in">NSAutoRelease</span> alloc]init];</span><br><span class="line"><span class="comment">//Code benefitting from a local autorelease pool.</span></span><br><span class="line"><span class="comment">//此处不可以使用break，return，goto之类的语句。</span></span><br><span class="line">[pool release];</span><br></pre></td></tr></table></figure></p><p>将需要写成<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"><span class="comment">//Code benefitting from a local autorelease pool.</span></span><br><span class="line"><span class="comment">//此处可以使用break，return，goto之类的语句。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>对一个 pool 发送 release 和 drain 的区别：</strong><br>在向 NSAutoreleasePool 发送 alloc 和 init 创建了一个 pool 以后，在销毁 pool 的时候可以向 pool 发送 drain 和 release 消息。macOS 支持垃圾回收，iOS 并不支持。在一个支持垃圾回收的环境中，是不需要使用 autorelease pool 的，但是假如你想编写一个库，而这个库又需要同时支持垃圾回收和引用计数的话，那么就需要使用 autorelease pool，在支持垃圾回收的环境中，向一个 pool 发送 drain 消息将会触发 pool 在必要的时候进行垃圾回收，而发送 release 就是一个空操作。而在一个引用计数的环境中，drain 和 release 所产生的效果相同。所以通常情况下，推荐使用 drain。</p><h2 id="八、便利构造器的情况"><a href="#八、便利构造器的情况" class="headerlink" title="八、便利构造器的情况"></a>八、便利构造器的情况</h2><p>当你使用 alloc、init 方法创建一个对象时，该对象的初始引用计数为1。当不再使用该对象时，你就要负责销毁它。<br>除了这种标准的创建对象的方法外，还有一种创建临时对象的方法，通过这种方法创建的对象都是临时对象，生成之后会被直接加入到内部的自动释放池，你不需要关心如何销毁它。<br>比如你需要创建一个数组 array 和一个字符串 string 的时候，使用了类似下面的方法：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span>* array=[<span class="built_in">NSArray</span> arrayWithArray: obj];         </span><br><span class="line"><span class="built_in">NSString</span>* string = [<span class="built_in">NSString</span> stringWithCString: <span class="string">"This is a temporary string"</span>];</span><br></pre></td></tr></table></figure></p><p>那么，array 和 string 就不需要我们手动负责内存管理。同使用 alloc 和 init 相比，这种不以 init 开头的初始化方法也称为便利构造器。    </p><h2 id="九、使用ARC的基本注意事项"><a href="#九、使用ARC的基本注意事项" class="headerlink" title="九、使用ARC的基本注意事项"></a>九、使用ARC的基本注意事项</h2><ul><li>不能在程序中定义和使用下列函数：retain、release、autorelease 和 retainCount    </li><li>使用 @autoreleasepool 代替 NSAutoreleasePool</li><li>方法命名必须遵循命名规则，不能随意定义以 alloc、init、new、copy、mutableCopy 开头且和所有权无关的方法</li><li>不能在 dealloc 中释放实例变量（但可以在 dealloc 中释放资源），也不需要调用 [super dealloc]</li><li>编译代码时使用编译器 clang，并加上编译选项 -fobjc-arc</li></ul>]]></content>
      
      <categories>
          
          <category> Objective-C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> objc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/cactus-dark/2015/12/25/Hello-World/"/>
      <url>/cactus-dark/2015/12/25/Hello-World/</url>
      <content type="html"><![CDATA[<p>Hello, the first blog just greetings.    </p><figure class="highlight c"><figcaption><span>hello.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"hello, world"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption><span>hello.cpp</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"Hello, Linda"</span>&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//so who is linda</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>hello.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> <span class="string">"Hello, world"</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>hello.java</span></figcaption><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">"Hello, world"</span>); </span><br></pre></td></tr></table></figure><figure class="highlight swift"><figcaption><span>hello.swift</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Hello, world"</span>)</span><br></pre></td></tr></table></figure><figure class="highlight objc"><figcaption><span>hello.m</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"Hello, world"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight golang"><figcaption><span>hello.go</span></figcaption><table><tr><td class="code"><pre><span class="line">fmt.Println(<span class="string">"Hello, world"</span>) </span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> essay </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
